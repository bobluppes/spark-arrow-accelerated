// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Types.proto

#include "Types.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_Types_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<12> scc_info_AndNode_Types_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_Types_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_BinaryConstants_Types_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_Types_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_BinaryNode_Types_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_Types_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_BooleanNode_Types_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_Types_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_DecimalNode_Types_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_Types_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_DoubleNode_Types_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_Types_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_ExpressionRoot_Types_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_Types_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ExtGandivaType_Types_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_Types_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Field_Types_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_Types_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_FieldNode_Types_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_Types_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_FloatNode_Types_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_Types_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_FunctionSignature_Types_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_Types_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<5> scc_info_InNode_Types_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_Types_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_IntConstants_Types_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_Types_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_IntNode_Types_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_Types_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_LongConstants_Types_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_Types_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_LongNode_Types_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_Types_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_NullNode_Types_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_Types_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_StringConstants_Types_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_Types_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_StringNode_Types_2eproto;
namespace types {
    class ExtGandivaTypeDefaultTypeInternal {
    public:
        ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ExtGandivaType> _instance;
    } _ExtGandivaType_default_instance_;
    class FieldDefaultTypeInternal {
    public:
        ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Field> _instance;
    } _Field_default_instance_;
    class FieldNodeDefaultTypeInternal {
    public:
        ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<FieldNode> _instance;
    } _FieldNode_default_instance_;
    class FunctionNodeDefaultTypeInternal {
    public:
        ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<FunctionNode> _instance;
    } _FunctionNode_default_instance_;
    class IfNodeDefaultTypeInternal {
    public:
        ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<IfNode> _instance;
    } _IfNode_default_instance_;
    class AndNodeDefaultTypeInternal {
    public:
        ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AndNode> _instance;
    } _AndNode_default_instance_;
    class OrNodeDefaultTypeInternal {
    public:
        ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<OrNode> _instance;
    } _OrNode_default_instance_;
    class NullNodeDefaultTypeInternal {
    public:
        ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<NullNode> _instance;
    } _NullNode_default_instance_;
    class IntNodeDefaultTypeInternal {
    public:
        ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<IntNode> _instance;
    } _IntNode_default_instance_;
    class FloatNodeDefaultTypeInternal {
    public:
        ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<FloatNode> _instance;
    } _FloatNode_default_instance_;
    class DoubleNodeDefaultTypeInternal {
    public:
        ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<DoubleNode> _instance;
    } _DoubleNode_default_instance_;
    class BooleanNodeDefaultTypeInternal {
    public:
        ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<BooleanNode> _instance;
    } _BooleanNode_default_instance_;
    class LongNodeDefaultTypeInternal {
    public:
        ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<LongNode> _instance;
    } _LongNode_default_instance_;
    class StringNodeDefaultTypeInternal {
    public:
        ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<StringNode> _instance;
    } _StringNode_default_instance_;
    class BinaryNodeDefaultTypeInternal {
    public:
        ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<BinaryNode> _instance;
    } _BinaryNode_default_instance_;
    class DecimalNodeDefaultTypeInternal {
    public:
        ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<DecimalNode> _instance;
    } _DecimalNode_default_instance_;
    class TreeNodeDefaultTypeInternal {
    public:
        ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TreeNode> _instance;
    } _TreeNode_default_instance_;
    class ExpressionRootDefaultTypeInternal {
    public:
        ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ExpressionRoot> _instance;
    } _ExpressionRoot_default_instance_;
    class ExpressionListDefaultTypeInternal {
    public:
        ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ExpressionList> _instance;
    } _ExpressionList_default_instance_;
    class ConditionDefaultTypeInternal {
    public:
        ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Condition> _instance;
    } _Condition_default_instance_;
    class SchemaDefaultTypeInternal {
    public:
        ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Schema> _instance;
    } _Schema_default_instance_;
    class GandivaDataTypesDefaultTypeInternal {
    public:
        ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<GandivaDataTypes> _instance;
    } _GandivaDataTypes_default_instance_;
    class GandivaFunctionsDefaultTypeInternal {
    public:
        ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<GandivaFunctions> _instance;
    } _GandivaFunctions_default_instance_;
    class FunctionSignatureDefaultTypeInternal {
    public:
        ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<FunctionSignature> _instance;
    } _FunctionSignature_default_instance_;
    class InNodeDefaultTypeInternal {
    public:
        ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<InNode> _instance;
    } _InNode_default_instance_;
    class IntConstantsDefaultTypeInternal {
    public:
        ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<IntConstants> _instance;
    } _IntConstants_default_instance_;
    class LongConstantsDefaultTypeInternal {
    public:
        ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<LongConstants> _instance;
    } _LongConstants_default_instance_;
    class StringConstantsDefaultTypeInternal {
    public:
        ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<StringConstants> _instance;
    } _StringConstants_default_instance_;
    class BinaryConstantsDefaultTypeInternal {
    public:
        ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<BinaryConstants> _instance;
    } _BinaryConstants_default_instance_;
}  // namespace types
static void InitDefaultsscc_info_AndNode_Types_2eproto() {
    GOOGLE_PROTOBUF_VERIFY_VERSION;

    {
        void* ptr = &::types::_FunctionNode_default_instance_;
        new (ptr) ::types::FunctionNode();
        ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
    }
    {
        void* ptr = &::types::_IfNode_default_instance_;
        new (ptr) ::types::IfNode();
        ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
    }
    {
        void* ptr = &::types::_AndNode_default_instance_;
        new (ptr) ::types::AndNode();
        ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
    }
    {
        void* ptr = &::types::_OrNode_default_instance_;
        new (ptr) ::types::OrNode();
        ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
    }
    {
        void* ptr = &::types::_TreeNode_default_instance_;
        new (ptr) ::types::TreeNode();
        ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
    }
    ::types::FunctionNode::InitAsDefaultInstance();
    ::types::IfNode::InitAsDefaultInstance();
    ::types::AndNode::InitAsDefaultInstance();
    ::types::OrNode::InitAsDefaultInstance();
    ::types::TreeNode::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<12> scc_info_AndNode_Types_2eproto =
        {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 12, 0, InitDefaultsscc_info_AndNode_Types_2eproto}, {
                &scc_info_ExtGandivaType_Types_2eproto.base,
                                                                                           &scc_info_FieldNode_Types_2eproto.base,
                                                                                               &scc_info_NullNode_Types_2eproto.base,
                                                                                                  &scc_info_IntNode_Types_2eproto.base,
                &scc_info_FloatNode_Types_2eproto.base,
                &scc_info_LongNode_Types_2eproto.base,
                &scc_info_BooleanNode_Types_2eproto.base,
                &scc_info_DoubleNode_Types_2eproto.base,
                &scc_info_StringNode_Types_2eproto.base,
                &scc_info_BinaryNode_Types_2eproto.base,
                &scc_info_DecimalNode_Types_2eproto.base,
                &scc_info_InNode_Types_2eproto.base,}};

static void InitDefaultsscc_info_BinaryConstants_Types_2eproto() {
    GOOGLE_PROTOBUF_VERIFY_VERSION;

    {
        void* ptr = &::types::_BinaryConstants_default_instance_;
        new (ptr) ::types::BinaryConstants();
        ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
    }
    ::types::BinaryConstants::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_BinaryConstants_Types_2eproto =
        {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_BinaryConstants_Types_2eproto}, {
                &scc_info_BinaryNode_Types_2eproto.base,}};

static void InitDefaultsscc_info_BinaryNode_Types_2eproto() {
    GOOGLE_PROTOBUF_VERIFY_VERSION;

    {
        void* ptr = &::types::_BinaryNode_default_instance_;
        new (ptr) ::types::BinaryNode();
        ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
    }
    ::types::BinaryNode::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_BinaryNode_Types_2eproto =
        {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_BinaryNode_Types_2eproto}, {}};

static void InitDefaultsscc_info_BooleanNode_Types_2eproto() {
    GOOGLE_PROTOBUF_VERIFY_VERSION;

    {
        void* ptr = &::types::_BooleanNode_default_instance_;
        new (ptr) ::types::BooleanNode();
        ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
    }
    ::types::BooleanNode::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_BooleanNode_Types_2eproto =
        {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_BooleanNode_Types_2eproto}, {}};

static void InitDefaultsscc_info_Condition_Types_2eproto() {
    GOOGLE_PROTOBUF_VERIFY_VERSION;

    {
        void* ptr = &::types::_Condition_default_instance_;
        new (ptr) ::types::Condition();
        ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
    }
    ::types::Condition::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Condition_Types_2eproto =
        {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_Condition_Types_2eproto}, {
                &scc_info_AndNode_Types_2eproto.base,}};

static void InitDefaultsscc_info_DecimalNode_Types_2eproto() {
    GOOGLE_PROTOBUF_VERIFY_VERSION;

    {
        void* ptr = &::types::_DecimalNode_default_instance_;
        new (ptr) ::types::DecimalNode();
        ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
    }
    ::types::DecimalNode::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_DecimalNode_Types_2eproto =
        {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_DecimalNode_Types_2eproto}, {}};

static void InitDefaultsscc_info_DoubleNode_Types_2eproto() {
    GOOGLE_PROTOBUF_VERIFY_VERSION;

    {
        void* ptr = &::types::_DoubleNode_default_instance_;
        new (ptr) ::types::DoubleNode();
        ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
    }
    ::types::DoubleNode::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_DoubleNode_Types_2eproto =
        {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_DoubleNode_Types_2eproto}, {}};

static void InitDefaultsscc_info_ExpressionList_Types_2eproto() {
    GOOGLE_PROTOBUF_VERIFY_VERSION;

    {
        void* ptr = &::types::_ExpressionList_default_instance_;
        new (ptr) ::types::ExpressionList();
        ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
    }
    ::types::ExpressionList::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ExpressionList_Types_2eproto =
        {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_ExpressionList_Types_2eproto}, {
                &scc_info_ExpressionRoot_Types_2eproto.base,}};

static void InitDefaultsscc_info_ExpressionRoot_Types_2eproto() {
    GOOGLE_PROTOBUF_VERIFY_VERSION;

    {
        void* ptr = &::types::_ExpressionRoot_default_instance_;
        new (ptr) ::types::ExpressionRoot();
        ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
    }
    ::types::ExpressionRoot::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_ExpressionRoot_Types_2eproto =
        {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_ExpressionRoot_Types_2eproto}, {
                &scc_info_AndNode_Types_2eproto.base,
                                                                                           &scc_info_Field_Types_2eproto.base,}};

static void InitDefaultsscc_info_ExtGandivaType_Types_2eproto() {
    GOOGLE_PROTOBUF_VERIFY_VERSION;

    {
        void* ptr = &::types::_ExtGandivaType_default_instance_;
        new (ptr) ::types::ExtGandivaType();
        ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
    }
    ::types::ExtGandivaType::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ExtGandivaType_Types_2eproto =
        {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_ExtGandivaType_Types_2eproto}, {}};

static void InitDefaultsscc_info_Field_Types_2eproto() {
    GOOGLE_PROTOBUF_VERIFY_VERSION;

    {
        void* ptr = &::types::_Field_default_instance_;
        new (ptr) ::types::Field();
        ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
    }
    ::types::Field::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Field_Types_2eproto =
        {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_Field_Types_2eproto}, {
                &scc_info_ExtGandivaType_Types_2eproto.base,}};

static void InitDefaultsscc_info_FieldNode_Types_2eproto() {
    GOOGLE_PROTOBUF_VERIFY_VERSION;

    {
        void* ptr = &::types::_FieldNode_default_instance_;
        new (ptr) ::types::FieldNode();
        ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
    }
    ::types::FieldNode::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_FieldNode_Types_2eproto =
        {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_FieldNode_Types_2eproto}, {
                &scc_info_Field_Types_2eproto.base,}};

static void InitDefaultsscc_info_FloatNode_Types_2eproto() {
    GOOGLE_PROTOBUF_VERIFY_VERSION;

    {
        void* ptr = &::types::_FloatNode_default_instance_;
        new (ptr) ::types::FloatNode();
        ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
    }
    ::types::FloatNode::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_FloatNode_Types_2eproto =
        {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_FloatNode_Types_2eproto}, {}};

static void InitDefaultsscc_info_FunctionSignature_Types_2eproto() {
    GOOGLE_PROTOBUF_VERIFY_VERSION;

    {
        void* ptr = &::types::_FunctionSignature_default_instance_;
        new (ptr) ::types::FunctionSignature();
        ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
    }
    ::types::FunctionSignature::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_FunctionSignature_Types_2eproto =
        {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_FunctionSignature_Types_2eproto}, {
                &scc_info_ExtGandivaType_Types_2eproto.base,}};

static void InitDefaultsscc_info_GandivaDataTypes_Types_2eproto() {
    GOOGLE_PROTOBUF_VERIFY_VERSION;

    {
        void* ptr = &::types::_GandivaDataTypes_default_instance_;
        new (ptr) ::types::GandivaDataTypes();
        ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
    }
    ::types::GandivaDataTypes::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_GandivaDataTypes_Types_2eproto =
        {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_GandivaDataTypes_Types_2eproto}, {
                &scc_info_ExtGandivaType_Types_2eproto.base,}};

static void InitDefaultsscc_info_GandivaFunctions_Types_2eproto() {
    GOOGLE_PROTOBUF_VERIFY_VERSION;

    {
        void* ptr = &::types::_GandivaFunctions_default_instance_;
        new (ptr) ::types::GandivaFunctions();
        ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
    }
    ::types::GandivaFunctions::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_GandivaFunctions_Types_2eproto =
        {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_GandivaFunctions_Types_2eproto}, {
                &scc_info_FunctionSignature_Types_2eproto.base,}};

static void InitDefaultsscc_info_InNode_Types_2eproto() {
    GOOGLE_PROTOBUF_VERIFY_VERSION;

    {
        void* ptr = &::types::_InNode_default_instance_;
        new (ptr) ::types::InNode();
        ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
    }
    ::types::InNode::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<5> scc_info_InNode_Types_2eproto =
        {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 5, 0, InitDefaultsscc_info_InNode_Types_2eproto}, {
                &scc_info_FieldNode_Types_2eproto.base,
                                                                                           &scc_info_IntConstants_Types_2eproto.base,
                                                                                              &scc_info_LongConstants_Types_2eproto.base,
                                                                                                 &scc_info_StringConstants_Types_2eproto.base,
                &scc_info_BinaryConstants_Types_2eproto.base,}};

static void InitDefaultsscc_info_IntConstants_Types_2eproto() {
    GOOGLE_PROTOBUF_VERIFY_VERSION;

    {
        void* ptr = &::types::_IntConstants_default_instance_;
        new (ptr) ::types::IntConstants();
        ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
    }
    ::types::IntConstants::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_IntConstants_Types_2eproto =
        {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_IntConstants_Types_2eproto}, {
                &scc_info_IntNode_Types_2eproto.base,}};

static void InitDefaultsscc_info_IntNode_Types_2eproto() {
    GOOGLE_PROTOBUF_VERIFY_VERSION;

    {
        void* ptr = &::types::_IntNode_default_instance_;
        new (ptr) ::types::IntNode();
        ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
    }
    ::types::IntNode::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_IntNode_Types_2eproto =
        {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_IntNode_Types_2eproto}, {}};

static void InitDefaultsscc_info_LongConstants_Types_2eproto() {
    GOOGLE_PROTOBUF_VERIFY_VERSION;

    {
        void* ptr = &::types::_LongConstants_default_instance_;
        new (ptr) ::types::LongConstants();
        ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
    }
    ::types::LongConstants::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_LongConstants_Types_2eproto =
        {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_LongConstants_Types_2eproto}, {
                &scc_info_LongNode_Types_2eproto.base,}};

static void InitDefaultsscc_info_LongNode_Types_2eproto() {
    GOOGLE_PROTOBUF_VERIFY_VERSION;

    {
        void* ptr = &::types::_LongNode_default_instance_;
        new (ptr) ::types::LongNode();
        ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
    }
    ::types::LongNode::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_LongNode_Types_2eproto =
        {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_LongNode_Types_2eproto}, {}};

static void InitDefaultsscc_info_NullNode_Types_2eproto() {
    GOOGLE_PROTOBUF_VERIFY_VERSION;

    {
        void* ptr = &::types::_NullNode_default_instance_;
        new (ptr) ::types::NullNode();
        ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
    }
    ::types::NullNode::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_NullNode_Types_2eproto =
        {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_NullNode_Types_2eproto}, {
                &scc_info_ExtGandivaType_Types_2eproto.base,}};

static void InitDefaultsscc_info_Schema_Types_2eproto() {
    GOOGLE_PROTOBUF_VERIFY_VERSION;

    {
        void* ptr = &::types::_Schema_default_instance_;
        new (ptr) ::types::Schema();
        ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
    }
    ::types::Schema::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Schema_Types_2eproto =
        {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_Schema_Types_2eproto}, {
                &scc_info_Field_Types_2eproto.base,}};

static void InitDefaultsscc_info_StringConstants_Types_2eproto() {
    GOOGLE_PROTOBUF_VERIFY_VERSION;

    {
        void* ptr = &::types::_StringConstants_default_instance_;
        new (ptr) ::types::StringConstants();
        ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
    }
    ::types::StringConstants::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_StringConstants_Types_2eproto =
        {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_StringConstants_Types_2eproto}, {
                &scc_info_StringNode_Types_2eproto.base,}};

static void InitDefaultsscc_info_StringNode_Types_2eproto() {
    GOOGLE_PROTOBUF_VERIFY_VERSION;

    {
        void* ptr = &::types::_StringNode_default_instance_;
        new (ptr) ::types::StringNode();
        ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
    }
    ::types::StringNode::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_StringNode_Types_2eproto =
        {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_StringNode_Types_2eproto}, {}};

static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_Types_2eproto[29];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_Types_2eproto[5];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_Types_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_Types_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        PROTOBUF_FIELD_OFFSET(::types::ExtGandivaType, _has_bits_),
        PROTOBUF_FIELD_OFFSET(::types::ExtGandivaType, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::types::ExtGandivaType, type_),
        PROTOBUF_FIELD_OFFSET(::types::ExtGandivaType, width_),
        PROTOBUF_FIELD_OFFSET(::types::ExtGandivaType, precision_),
        PROTOBUF_FIELD_OFFSET(::types::ExtGandivaType, scale_),
        PROTOBUF_FIELD_OFFSET(::types::ExtGandivaType, dateunit_),
        PROTOBUF_FIELD_OFFSET(::types::ExtGandivaType, timeunit_),
        PROTOBUF_FIELD_OFFSET(::types::ExtGandivaType, timezone_),
        PROTOBUF_FIELD_OFFSET(::types::ExtGandivaType, intervaltype_),
        1,
        2,
        3,
        4,
        5,
        6,
        0,
        7,
        PROTOBUF_FIELD_OFFSET(::types::Field, _has_bits_),
        PROTOBUF_FIELD_OFFSET(::types::Field, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::types::Field, name_),
        PROTOBUF_FIELD_OFFSET(::types::Field, type_),
        PROTOBUF_FIELD_OFFSET(::types::Field, nullable_),
        PROTOBUF_FIELD_OFFSET(::types::Field, children_),
        0,
        1,
        2,
        ~0u,
        PROTOBUF_FIELD_OFFSET(::types::FieldNode, _has_bits_),
        PROTOBUF_FIELD_OFFSET(::types::FieldNode, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::types::FieldNode, field_),
        0,
        PROTOBUF_FIELD_OFFSET(::types::FunctionNode, _has_bits_),
        PROTOBUF_FIELD_OFFSET(::types::FunctionNode, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::types::FunctionNode, functionname_),
        PROTOBUF_FIELD_OFFSET(::types::FunctionNode, inargs_),
        PROTOBUF_FIELD_OFFSET(::types::FunctionNode, returntype_),
        0,
        ~0u,
        1,
        PROTOBUF_FIELD_OFFSET(::types::IfNode, _has_bits_),
        PROTOBUF_FIELD_OFFSET(::types::IfNode, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::types::IfNode, cond_),
        PROTOBUF_FIELD_OFFSET(::types::IfNode, thennode_),
        PROTOBUF_FIELD_OFFSET(::types::IfNode, elsenode_),
        PROTOBUF_FIELD_OFFSET(::types::IfNode, returntype_),
        0,
        1,
        2,
        3,
        PROTOBUF_FIELD_OFFSET(::types::AndNode, _has_bits_),
        PROTOBUF_FIELD_OFFSET(::types::AndNode, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::types::AndNode, args_),
        ~0u,
        PROTOBUF_FIELD_OFFSET(::types::OrNode, _has_bits_),
        PROTOBUF_FIELD_OFFSET(::types::OrNode, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::types::OrNode, args_),
        ~0u,
        PROTOBUF_FIELD_OFFSET(::types::NullNode, _has_bits_),
        PROTOBUF_FIELD_OFFSET(::types::NullNode, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::types::NullNode, type_),
        0,
        PROTOBUF_FIELD_OFFSET(::types::IntNode, _has_bits_),
        PROTOBUF_FIELD_OFFSET(::types::IntNode, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::types::IntNode, value_),
        0,
        PROTOBUF_FIELD_OFFSET(::types::FloatNode, _has_bits_),
        PROTOBUF_FIELD_OFFSET(::types::FloatNode, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::types::FloatNode, value_),
        0,
        PROTOBUF_FIELD_OFFSET(::types::DoubleNode, _has_bits_),
        PROTOBUF_FIELD_OFFSET(::types::DoubleNode, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::types::DoubleNode, value_),
        0,
        PROTOBUF_FIELD_OFFSET(::types::BooleanNode, _has_bits_),
        PROTOBUF_FIELD_OFFSET(::types::BooleanNode, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::types::BooleanNode, value_),
        0,
        PROTOBUF_FIELD_OFFSET(::types::LongNode, _has_bits_),
        PROTOBUF_FIELD_OFFSET(::types::LongNode, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::types::LongNode, value_),
        0,
        PROTOBUF_FIELD_OFFSET(::types::StringNode, _has_bits_),
        PROTOBUF_FIELD_OFFSET(::types::StringNode, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::types::StringNode, value_),
        0,
        PROTOBUF_FIELD_OFFSET(::types::BinaryNode, _has_bits_),
        PROTOBUF_FIELD_OFFSET(::types::BinaryNode, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::types::BinaryNode, value_),
        0,
        PROTOBUF_FIELD_OFFSET(::types::DecimalNode, _has_bits_),
        PROTOBUF_FIELD_OFFSET(::types::DecimalNode, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::types::DecimalNode, value_),
        PROTOBUF_FIELD_OFFSET(::types::DecimalNode, precision_),
        PROTOBUF_FIELD_OFFSET(::types::DecimalNode, scale_),
        0,
        1,
        2,
        PROTOBUF_FIELD_OFFSET(::types::TreeNode, _has_bits_),
        PROTOBUF_FIELD_OFFSET(::types::TreeNode, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::types::TreeNode, fieldnode_),
        PROTOBUF_FIELD_OFFSET(::types::TreeNode, fnnode_),
        PROTOBUF_FIELD_OFFSET(::types::TreeNode, ifnode_),
        PROTOBUF_FIELD_OFFSET(::types::TreeNode, andnode_),
        PROTOBUF_FIELD_OFFSET(::types::TreeNode, ornode_),
        PROTOBUF_FIELD_OFFSET(::types::TreeNode, nullnode_),
        PROTOBUF_FIELD_OFFSET(::types::TreeNode, intnode_),
        PROTOBUF_FIELD_OFFSET(::types::TreeNode, floatnode_),
        PROTOBUF_FIELD_OFFSET(::types::TreeNode, longnode_),
        PROTOBUF_FIELD_OFFSET(::types::TreeNode, booleannode_),
        PROTOBUF_FIELD_OFFSET(::types::TreeNode, doublenode_),
        PROTOBUF_FIELD_OFFSET(::types::TreeNode, stringnode_),
        PROTOBUF_FIELD_OFFSET(::types::TreeNode, binarynode_),
        PROTOBUF_FIELD_OFFSET(::types::TreeNode, decimalnode_),
        PROTOBUF_FIELD_OFFSET(::types::TreeNode, innode_),
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        PROTOBUF_FIELD_OFFSET(::types::ExpressionRoot, _has_bits_),
        PROTOBUF_FIELD_OFFSET(::types::ExpressionRoot, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::types::ExpressionRoot, root_),
        PROTOBUF_FIELD_OFFSET(::types::ExpressionRoot, resulttype_),
        0,
        1,
        PROTOBUF_FIELD_OFFSET(::types::ExpressionList, _has_bits_),
        PROTOBUF_FIELD_OFFSET(::types::ExpressionList, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::types::ExpressionList, exprs_),
        ~0u,
        PROTOBUF_FIELD_OFFSET(::types::Condition, _has_bits_),
        PROTOBUF_FIELD_OFFSET(::types::Condition, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::types::Condition, root_),
        0,
        PROTOBUF_FIELD_OFFSET(::types::Schema, _has_bits_),
        PROTOBUF_FIELD_OFFSET(::types::Schema, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::types::Schema, columns_),
        ~0u,
        PROTOBUF_FIELD_OFFSET(::types::GandivaDataTypes, _has_bits_),
        PROTOBUF_FIELD_OFFSET(::types::GandivaDataTypes, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::types::GandivaDataTypes, datatype_),
        ~0u,
        PROTOBUF_FIELD_OFFSET(::types::GandivaFunctions, _has_bits_),
        PROTOBUF_FIELD_OFFSET(::types::GandivaFunctions, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::types::GandivaFunctions, function_),
        ~0u,
        PROTOBUF_FIELD_OFFSET(::types::FunctionSignature, _has_bits_),
        PROTOBUF_FIELD_OFFSET(::types::FunctionSignature, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::types::FunctionSignature, name_),
        PROTOBUF_FIELD_OFFSET(::types::FunctionSignature, returntype_),
        PROTOBUF_FIELD_OFFSET(::types::FunctionSignature, paramtypes_),
        0,
        1,
        ~0u,
        PROTOBUF_FIELD_OFFSET(::types::InNode, _has_bits_),
        PROTOBUF_FIELD_OFFSET(::types::InNode, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::types::InNode, field_),
        PROTOBUF_FIELD_OFFSET(::types::InNode, intvalues_),
        PROTOBUF_FIELD_OFFSET(::types::InNode, longvalues_),
        PROTOBUF_FIELD_OFFSET(::types::InNode, stringvalues_),
        PROTOBUF_FIELD_OFFSET(::types::InNode, binaryvalues_),
        0,
        1,
        2,
        3,
        4,
        PROTOBUF_FIELD_OFFSET(::types::IntConstants, _has_bits_),
        PROTOBUF_FIELD_OFFSET(::types::IntConstants, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::types::IntConstants, intvalues_),
        ~0u,
        PROTOBUF_FIELD_OFFSET(::types::LongConstants, _has_bits_),
        PROTOBUF_FIELD_OFFSET(::types::LongConstants, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::types::LongConstants, longvalues_),
        ~0u,
        PROTOBUF_FIELD_OFFSET(::types::StringConstants, _has_bits_),
        PROTOBUF_FIELD_OFFSET(::types::StringConstants, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::types::StringConstants, stringvalues_),
        ~0u,
        PROTOBUF_FIELD_OFFSET(::types::BinaryConstants, _has_bits_),
        PROTOBUF_FIELD_OFFSET(::types::BinaryConstants, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::types::BinaryConstants, binaryvalues_),
        ~0u,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        { 0, 13, sizeof(::types::ExtGandivaType)},
        { 21, 30, sizeof(::types::Field)},
        { 34, 40, sizeof(::types::FieldNode)},
        { 41, 49, sizeof(::types::FunctionNode)},
        { 52, 61, sizeof(::types::IfNode)},
        { 65, 71, sizeof(::types::AndNode)},
        { 72, 78, sizeof(::types::OrNode)},
        { 79, 85, sizeof(::types::NullNode)},
        { 86, 92, sizeof(::types::IntNode)},
        { 93, 99, sizeof(::types::FloatNode)},
        { 100, 106, sizeof(::types::DoubleNode)},
        { 107, 113, sizeof(::types::BooleanNode)},
        { 114, 120, sizeof(::types::LongNode)},
        { 121, 127, sizeof(::types::StringNode)},
        { 128, 134, sizeof(::types::BinaryNode)},
        { 135, 143, sizeof(::types::DecimalNode)},
        { 146, 166, sizeof(::types::TreeNode)},
        { 181, 188, sizeof(::types::ExpressionRoot)},
        { 190, 196, sizeof(::types::ExpressionList)},
        { 197, 203, sizeof(::types::Condition)},
        { 204, 210, sizeof(::types::Schema)},
        { 211, 217, sizeof(::types::GandivaDataTypes)},
        { 218, 224, sizeof(::types::GandivaFunctions)},
        { 225, 233, sizeof(::types::FunctionSignature)},
        { 236, 246, sizeof(::types::InNode)},
        { 251, 257, sizeof(::types::IntConstants)},
        { 258, 264, sizeof(::types::LongConstants)},
        { 265, 271, sizeof(::types::StringConstants)},
        { 272, 278, sizeof(::types::BinaryConstants)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::types::_ExtGandivaType_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::types::_Field_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::types::_FieldNode_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::types::_FunctionNode_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::types::_IfNode_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::types::_AndNode_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::types::_OrNode_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::types::_NullNode_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::types::_IntNode_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::types::_FloatNode_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::types::_DoubleNode_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::types::_BooleanNode_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::types::_LongNode_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::types::_StringNode_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::types::_BinaryNode_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::types::_DecimalNode_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::types::_TreeNode_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::types::_ExpressionRoot_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::types::_ExpressionList_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::types::_Condition_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::types::_Schema_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::types::_GandivaDataTypes_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::types::_GandivaFunctions_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::types::_FunctionSignature_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::types::_InNode_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::types::_IntConstants_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::types::_LongConstants_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::types::_StringConstants_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::types::_BinaryConstants_default_instance_),
};

const char descriptor_table_protodef_Types_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
        "\n\013Types.proto\022\005types\"\346\001\n\016ExtGandivaType\022"
        " \n\004type\030\001 \001(\0162\022.types.GandivaType\022\r\n\005wid"
        "th\030\002 \001(\r\022\021\n\tprecision\030\003 \001(\005\022\r\n\005scale\030\004 \001"
        "(\005\022!\n\010dateUnit\030\005 \001(\0162\017.types.DateUnit\022!\n"
        "\010timeUnit\030\006 \001(\0162\017.types.TimeUnit\022\020\n\010time"
        "Zone\030\007 \001(\t\022)\n\014intervalType\030\010 \001(\0162\023.types"
        ".IntervalType\"l\n\005Field\022\014\n\004name\030\001 \001(\t\022#\n\004"
        "type\030\002 \001(\0132\025.types.ExtGandivaType\022\020\n\010nul"
        "lable\030\003 \001(\010\022\036\n\010children\030\004 \003(\0132\014.types.Fi"
        "eld\"(\n\tFieldNode\022\033\n\005field\030\001 \001(\0132\014.types."
        "Field\"p\n\014FunctionNode\022\024\n\014functionName\030\001 "
        "\001(\t\022\037\n\006inArgs\030\002 \003(\0132\017.types.TreeNode\022)\n\n"
        "returnType\030\003 \001(\0132\025.types.ExtGandivaType\""
        "\230\001\n\006IfNode\022\035\n\004cond\030\001 \001(\0132\017.types.TreeNod"
        "e\022!\n\010thenNode\030\002 \001(\0132\017.types.TreeNode\022!\n\010"
        "elseNode\030\003 \001(\0132\017.types.TreeNode\022)\n\nretur"
        "nType\030\004 \001(\0132\025.types.ExtGandivaType\"(\n\007An"
        "dNode\022\035\n\004args\030\001 \003(\0132\017.types.TreeNode\"\'\n\006"
        "OrNode\022\035\n\004args\030\001 \003(\0132\017.types.TreeNode\"/\n"
        "\010NullNode\022#\n\004type\030\001 \001(\0132\025.types.ExtGandi"
        "vaType\"\030\n\007IntNode\022\r\n\005value\030\001 \001(\005\"\032\n\tFloa"
        "tNode\022\r\n\005value\030\001 \001(\002\"\033\n\nDoubleNode\022\r\n\005va"
        "lue\030\001 \001(\001\"\034\n\013BooleanNode\022\r\n\005value\030\001 \001(\010\""
        "\031\n\010LongNode\022\r\n\005value\030\001 \001(\003\"\033\n\nStringNode"
        "\022\r\n\005value\030\001 \001(\014\"\033\n\nBinaryNode\022\r\n\005value\030\001"
        " \001(\014\">\n\013DecimalNode\022\r\n\005value\030\001 \001(\t\022\021\n\tpr"
        "ecision\030\002 \001(\005\022\r\n\005scale\030\003 \001(\005\"\245\004\n\010TreeNod"
        "e\022#\n\tfieldNode\030\001 \001(\0132\020.types.FieldNode\022#"
        "\n\006fnNode\030\002 \001(\0132\023.types.FunctionNode\022\035\n\006i"
        "fNode\030\006 \001(\0132\r.types.IfNode\022\037\n\007andNode\030\007 "
        "\001(\0132\016.types.AndNode\022\035\n\006orNode\030\010 \001(\0132\r.ty"
        "pes.OrNode\022!\n\010nullNode\030\013 \001(\0132\017.types.Nul"
        "lNode\022\037\n\007intNode\030\014 \001(\0132\016.types.IntNode\022#"
        "\n\tfloatNode\030\r \001(\0132\020.types.FloatNode\022!\n\010l"
        "ongNode\030\016 \001(\0132\017.types.LongNode\022\'\n\013boolea"
        "nNode\030\017 \001(\0132\022.types.BooleanNode\022%\n\ndoubl"
        "eNode\030\020 \001(\0132\021.types.DoubleNode\022%\n\nstring"
        "Node\030\021 \001(\0132\021.types.StringNode\022%\n\nbinaryN"
        "ode\030\022 \001(\0132\021.types.BinaryNode\022\'\n\013decimalN"
        "ode\030\023 \001(\0132\022.types.DecimalNode\022\035\n\006inNode\030"
        "\025 \001(\0132\r.types.InNode\"Q\n\016ExpressionRoot\022\035"
        "\n\004root\030\001 \001(\0132\017.types.TreeNode\022 \n\nresultT"
        "ype\030\002 \001(\0132\014.types.Field\"6\n\016ExpressionLis"
        "t\022$\n\005exprs\030\002 \003(\0132\025.types.ExpressionRoot\""
        "*\n\tCondition\022\035\n\004root\030\001 \001(\0132\017.types.TreeN"
        "ode\"\'\n\006Schema\022\035\n\007columns\030\001 \003(\0132\014.types.F"
        "ield\";\n\020GandivaDataTypes\022\'\n\010dataType\030\001 \003"
        "(\0132\025.types.ExtGandivaType\">\n\020GandivaFunc"
        "tions\022*\n\010function\030\001 \003(\0132\030.types.Function"
        "Signature\"w\n\021FunctionSignature\022\014\n\004name\030\001"
        " \001(\t\022)\n\nreturnType\030\002 \001(\0132\025.types.ExtGand"
        "ivaType\022)\n\nparamTypes\030\003 \003(\0132\025.types.ExtG"
        "andivaType\"\327\001\n\006InNode\022\037\n\005field\030\001 \001(\0132\020.t"
        "ypes.FieldNode\022&\n\tintValues\030\002 \001(\0132\023.type"
        "s.IntConstants\022(\n\nlongValues\030\003 \001(\0132\024.typ"
        "es.LongConstants\022,\n\014stringValues\030\004 \001(\0132\026"
        ".types.StringConstants\022,\n\014binaryValues\030\005"
        " \001(\0132\026.types.BinaryConstants\"1\n\014IntConst"
        "ants\022!\n\tintValues\030\001 \003(\0132\016.types.IntNode\""
        "4\n\rLongConstants\022#\n\nlongValues\030\001 \003(\0132\017.t"
        "ypes.LongNode\":\n\017StringConstants\022\'\n\014stri"
        "ngValues\030\001 \003(\0132\021.types.StringNode\":\n\017Bin"
        "aryConstants\022\'\n\014binaryValues\030\001 \003(\0132\021.typ"
        "es.BinaryNode*\343\002\n\013GandivaType\022\010\n\004NONE\020\000\022"
        "\010\n\004BOOL\020\001\022\t\n\005UINT8\020\002\022\010\n\004INT8\020\003\022\n\n\006UINT16"
        "\020\004\022\t\n\005INT16\020\005\022\n\n\006UINT32\020\006\022\t\n\005INT32\020\007\022\n\n\006"
        "UINT64\020\010\022\t\n\005INT64\020\t\022\016\n\nHALF_FLOAT\020\n\022\t\n\005F"
        "LOAT\020\013\022\n\n\006DOUBLE\020\014\022\010\n\004UTF8\020\r\022\n\n\006BINARY\020\016"
        "\022\025\n\021FIXED_SIZE_BINARY\020\017\022\n\n\006DATE32\020\020\022\n\n\006D"
        "ATE64\020\021\022\r\n\tTIMESTAMP\020\022\022\n\n\006TIME32\020\023\022\n\n\006TI"
        "ME64\020\024\022\014\n\010INTERVAL\020\025\022\013\n\007DECIMAL\020\026\022\010\n\004LIS"
        "T\020\027\022\n\n\006STRUCT\020\030\022\t\n\005UNION\020\031\022\016\n\nDICTIONARY"
        "\020\032\022\007\n\003MAP\020\033*\036\n\010DateUnit\022\007\n\003DAY\020\000\022\t\n\005MILL"
        "I\020\001*<\n\010TimeUnit\022\007\n\003SEC\020\000\022\014\n\010MILLISEC\020\001\022\014"
        "\n\010MICROSEC\020\002\022\013\n\007NANOSEC\020\003*,\n\014IntervalTyp"
        "e\022\016\n\nYEAR_MONTH\020\000\022\014\n\010DAY_TIME\020\001*>\n\023Selec"
        "tionVectorType\022\013\n\007SV_NONE\020\000\022\014\n\010SV_INT16\020"
        "\001\022\014\n\010SV_INT32\020\002B.\n\034org.apache.arrow.gand"
        "iva.ipcB\014GandivaTypesH\001"
;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_Types_2eproto_deps[1] = {
};
static ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase*const descriptor_table_Types_2eproto_sccs[25] = {
        &scc_info_AndNode_Types_2eproto.base,
        &scc_info_BinaryConstants_Types_2eproto.base,
        &scc_info_BinaryNode_Types_2eproto.base,
        &scc_info_BooleanNode_Types_2eproto.base,
        &scc_info_Condition_Types_2eproto.base,
        &scc_info_DecimalNode_Types_2eproto.base,
        &scc_info_DoubleNode_Types_2eproto.base,
        &scc_info_ExpressionList_Types_2eproto.base,
        &scc_info_ExpressionRoot_Types_2eproto.base,
        &scc_info_ExtGandivaType_Types_2eproto.base,
        &scc_info_Field_Types_2eproto.base,
        &scc_info_FieldNode_Types_2eproto.base,
        &scc_info_FloatNode_Types_2eproto.base,
        &scc_info_FunctionSignature_Types_2eproto.base,
        &scc_info_GandivaDataTypes_Types_2eproto.base,
        &scc_info_GandivaFunctions_Types_2eproto.base,
        &scc_info_InNode_Types_2eproto.base,
        &scc_info_IntConstants_Types_2eproto.base,
        &scc_info_IntNode_Types_2eproto.base,
        &scc_info_LongConstants_Types_2eproto.base,
        &scc_info_LongNode_Types_2eproto.base,
        &scc_info_NullNode_Types_2eproto.base,
        &scc_info_Schema_Types_2eproto.base,
        &scc_info_StringConstants_Types_2eproto.base,
        &scc_info_StringNode_Types_2eproto.base,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_Types_2eproto_once;
static bool descriptor_table_Types_2eproto_initialized = false;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Types_2eproto = {
        &descriptor_table_Types_2eproto_initialized, descriptor_table_protodef_Types_2eproto, "Types.proto", 3143,
        &descriptor_table_Types_2eproto_once, descriptor_table_Types_2eproto_sccs, descriptor_table_Types_2eproto_deps, 25, 0,
        schemas, file_default_instances, TableStruct_Types_2eproto::offsets,
        file_level_metadata_Types_2eproto, 29, file_level_enum_descriptors_Types_2eproto, file_level_service_descriptors_Types_2eproto,
};

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_Types_2eproto = (  ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptors(&descriptor_table_Types_2eproto), true);
namespace types {
    const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GandivaType_descriptor() {
        ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Types_2eproto);
        return file_level_enum_descriptors_Types_2eproto[0];
    }
    bool GandivaType_IsValid(int value) {
        switch (value) {
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
            case 22:
            case 23:
            case 24:
            case 25:
            case 26:
            case 27:
                return true;
            default:
                return false;
        }
    }

    const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DateUnit_descriptor() {
        ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Types_2eproto);
        return file_level_enum_descriptors_Types_2eproto[1];
    }
    bool DateUnit_IsValid(int value) {
        switch (value) {
            case 0:
            case 1:
                return true;
            default:
                return false;
        }
    }

    const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TimeUnit_descriptor() {
        ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Types_2eproto);
        return file_level_enum_descriptors_Types_2eproto[2];
    }
    bool TimeUnit_IsValid(int value) {
        switch (value) {
            case 0:
            case 1:
            case 2:
            case 3:
                return true;
            default:
                return false;
        }
    }

    const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IntervalType_descriptor() {
        ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Types_2eproto);
        return file_level_enum_descriptors_Types_2eproto[3];
    }
    bool IntervalType_IsValid(int value) {
        switch (value) {
            case 0:
            case 1:
                return true;
            default:
                return false;
        }
    }

    const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SelectionVectorType_descriptor() {
        ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Types_2eproto);
        return file_level_enum_descriptors_Types_2eproto[4];
    }
    bool SelectionVectorType_IsValid(int value) {
        switch (value) {
            case 0:
            case 1:
            case 2:
                return true;
            default:
                return false;
        }
    }


// ===================================================================

    void ExtGandivaType::InitAsDefaultInstance() {
    }
    class ExtGandivaType::_Internal {
    public:
        using HasBits = decltype(std::declval<ExtGandivaType>()._has_bits_);
        static void set_has_type(HasBits* has_bits) {
            (*has_bits)[0] |= 2u;
        }
        static void set_has_width(HasBits* has_bits) {
            (*has_bits)[0] |= 4u;
        }
        static void set_has_precision(HasBits* has_bits) {
            (*has_bits)[0] |= 8u;
        }
        static void set_has_scale(HasBits* has_bits) {
            (*has_bits)[0] |= 16u;
        }
        static void set_has_dateunit(HasBits* has_bits) {
            (*has_bits)[0] |= 32u;
        }
        static void set_has_timeunit(HasBits* has_bits) {
            (*has_bits)[0] |= 64u;
        }
        static void set_has_timezone(HasBits* has_bits) {
            (*has_bits)[0] |= 1u;
        }
        static void set_has_intervaltype(HasBits* has_bits) {
            (*has_bits)[0] |= 128u;
        }
    };

    ExtGandivaType::ExtGandivaType()
            : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
        SharedCtor();
        // @@protoc_insertion_point(constructor:types.ExtGandivaType)
    }
    ExtGandivaType::ExtGandivaType(const ExtGandivaType& from)
            : ::PROTOBUF_NAMESPACE_ID::Message(),
              _internal_metadata_(nullptr),
              _has_bits_(from._has_bits_) {
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        timezone_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
        if (from._internal_has_timezone()) {
            timezone_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.timezone_);
        }
        ::memcpy(&type_, &from.type_,
                 static_cast<size_t>(reinterpret_cast<char*>(&intervaltype_) -
                                     reinterpret_cast<char*>(&type_)) + sizeof(intervaltype_));
        // @@protoc_insertion_point(copy_constructor:types.ExtGandivaType)
    }

    void ExtGandivaType::SharedCtor() {
        ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ExtGandivaType_Types_2eproto.base);
        timezone_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
        ::memset(&type_, 0, static_cast<size_t>(
                                    reinterpret_cast<char*>(&intervaltype_) -
                                    reinterpret_cast<char*>(&type_)) + sizeof(intervaltype_));
    }

    ExtGandivaType::~ExtGandivaType() {
        // @@protoc_insertion_point(destructor:types.ExtGandivaType)
        SharedDtor();
    }

    void ExtGandivaType::SharedDtor() {
        timezone_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
    }

    void ExtGandivaType::SetCachedSize(int size) const {
        _cached_size_.Set(size);
    }
    const ExtGandivaType& ExtGandivaType::default_instance() {
        ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ExtGandivaType_Types_2eproto.base);
        return *internal_default_instance();
    }


    void ExtGandivaType::Clear() {
// @@protoc_insertion_point(message_clear_start:types.ExtGandivaType)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        cached_has_bits = _has_bits_[0];
        if (cached_has_bits & 0x00000001u) {
            timezone_.ClearNonDefaultToEmptyNoArena();
        }
        if (cached_has_bits & 0x000000feu) {
            ::memset(&type_, 0, static_cast<size_t>(
                                        reinterpret_cast<char*>(&intervaltype_) -
                                        reinterpret_cast<char*>(&type_)) + sizeof(intervaltype_));
        }
        _has_bits_.Clear();
        _internal_metadata_.Clear();
    }

    const char* ExtGandivaType::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
        _Internal::HasBits has_bits{};
        while (!ctx->Done(&ptr)) {
            ::PROTOBUF_NAMESPACE_ID::uint32 tag;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
            CHK_(ptr);
            switch (tag >> 3) {
                // optional .types.GandivaType type = 1;
                case 1:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
                        ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
                        CHK_(ptr);
                        if (PROTOBUF_PREDICT_TRUE(::types::GandivaType_IsValid(val))) {
                            _internal_set_type(static_cast<::types::GandivaType>(val));
                        } else {
                            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                        }
                    } else goto handle_unusual;
                    continue;
                    // optional uint32 width = 2;
                case 2:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
                        _Internal::set_has_width(&has_bits);
                        width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
                        CHK_(ptr);
                    } else goto handle_unusual;
                    continue;
                    // optional int32 precision = 3;
                case 3:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
                        _Internal::set_has_precision(&has_bits);
                        precision_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
                        CHK_(ptr);
                    } else goto handle_unusual;
                    continue;
                    // optional int32 scale = 4;
                case 4:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
                        _Internal::set_has_scale(&has_bits);
                        scale_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
                        CHK_(ptr);
                    } else goto handle_unusual;
                    continue;
                    // optional .types.DateUnit dateUnit = 5;
                case 5:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
                        ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
                        CHK_(ptr);
                        if (PROTOBUF_PREDICT_TRUE(::types::DateUnit_IsValid(val))) {
                            _internal_set_dateunit(static_cast<::types::DateUnit>(val));
                        } else {
                            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
                        }
                    } else goto handle_unusual;
                    continue;
                    // optional .types.TimeUnit timeUnit = 6;
                case 6:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
                        ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
                        CHK_(ptr);
                        if (PROTOBUF_PREDICT_TRUE(::types::TimeUnit_IsValid(val))) {
                            _internal_set_timeunit(static_cast<::types::TimeUnit>(val));
                        } else {
                            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
                        }
                    } else goto handle_unusual;
                    continue;
                    // optional string timeZone = 7;
                case 7:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
                        auto str = _internal_mutable_timezone();
                        ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
#ifndef NDEBUG
                        ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "types.ExtGandivaType.timeZone");
#endif  // !NDEBUG
                        CHK_(ptr);
                    } else goto handle_unusual;
                    continue;
                    // optional .types.IntervalType intervalType = 8;
                case 8:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
                        ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
                        CHK_(ptr);
                        if (PROTOBUF_PREDICT_TRUE(::types::IntervalType_IsValid(val))) {
                            _internal_set_intervaltype(static_cast<::types::IntervalType>(val));
                        } else {
                            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(8, val, mutable_unknown_fields());
                        }
                    } else goto handle_unusual;
                    continue;
                default: {
                    handle_unusual:
                    if ((tag & 7) == 4 || tag == 0) {
                        ctx->SetLastTag(tag);
                        goto success;
                    }
                    ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
                    CHK_(ptr != nullptr);
                    continue;
                }
            }  // switch
        }  // while
        success:
        _has_bits_.Or(has_bits);
        return ptr;
        failure:
        ptr = nullptr;
        goto success;
#undef CHK_
    }

    ::PROTOBUF_NAMESPACE_ID::uint8* ExtGandivaType::_InternalSerialize(
            ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
        // @@protoc_insertion_point(serialize_to_array_start:types.ExtGandivaType)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        cached_has_bits = _has_bits_[0];
        // optional .types.GandivaType type = 1;
        if (cached_has_bits & 0x00000002u) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
                    1, this->_internal_type(), target);
        }

        // optional uint32 width = 2;
        if (cached_has_bits & 0x00000004u) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_width(), target);
        }

        // optional int32 precision = 3;
        if (cached_has_bits & 0x00000008u) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_precision(), target);
        }

        // optional int32 scale = 4;
        if (cached_has_bits & 0x00000010u) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_scale(), target);
        }

        // optional .types.DateUnit dateUnit = 5;
        if (cached_has_bits & 0x00000020u) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
                    5, this->_internal_dateunit(), target);
        }

        // optional .types.TimeUnit timeUnit = 6;
        if (cached_has_bits & 0x00000040u) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
                    6, this->_internal_timeunit(), target);
        }

        // optional string timeZone = 7;
        if (cached_has_bits & 0x00000001u) {
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
                    this->_internal_timezone().data(), static_cast<int>(this->_internal_timezone().length()),
                    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                    "types.ExtGandivaType.timeZone");
            target = stream->WriteStringMaybeAliased(
                    7, this->_internal_timezone(), target);
        }

        // optional .types.IntervalType intervalType = 8;
        if (cached_has_bits & 0x00000080u) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
                    8, this->_internal_intervaltype(), target);
        }

        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
                    _internal_metadata_.unknown_fields(), target, stream);
        }
        // @@protoc_insertion_point(serialize_to_array_end:types.ExtGandivaType)
        return target;
    }

    size_t ExtGandivaType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:types.ExtGandivaType)
        size_t total_size = 0;

        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        cached_has_bits = _has_bits_[0];
        if (cached_has_bits & 0x000000ffu) {
            // optional string timeZone = 7;
            if (cached_has_bits & 0x00000001u) {
                total_size += 1 +
                              ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_timezone());
            }

            // optional .types.GandivaType type = 1;
            if (cached_has_bits & 0x00000002u) {
                total_size += 1 +
                              ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
            }

            // optional uint32 width = 2;
            if (cached_has_bits & 0x00000004u) {
                total_size += 1 +
                              ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
                                      this->_internal_width());
            }

            // optional int32 precision = 3;
            if (cached_has_bits & 0x00000008u) {
                total_size += 1 +
                              ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
                                      this->_internal_precision());
            }

            // optional int32 scale = 4;
            if (cached_has_bits & 0x00000010u) {
                total_size += 1 +
                              ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
                                      this->_internal_scale());
            }

            // optional .types.DateUnit dateUnit = 5;
            if (cached_has_bits & 0x00000020u) {
                total_size += 1 +
                              ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_dateunit());
            }

            // optional .types.TimeUnit timeUnit = 6;
            if (cached_has_bits & 0x00000040u) {
                total_size += 1 +
                              ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_timeunit());
            }

            // optional .types.IntervalType intervalType = 8;
            if (cached_has_bits & 0x00000080u) {
                total_size += 1 +
                              ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_intervaltype());
            }

        }
        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
                    _internal_metadata_, total_size, &_cached_size_);
        }
        int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
        SetCachedSize(cached_size);
        return total_size;
    }

    void ExtGandivaType::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:types.ExtGandivaType)
                GOOGLE_DCHECK_NE(&from, this);
        const ExtGandivaType* source =
                ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ExtGandivaType>(
                        &from);
        if (source == nullptr) {
            // @@protoc_insertion_point(generalized_merge_from_cast_fail:types.ExtGandivaType)
            ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
        } else {
            // @@protoc_insertion_point(generalized_merge_from_cast_success:types.ExtGandivaType)
            MergeFrom(*source);
        }
    }

    void ExtGandivaType::MergeFrom(const ExtGandivaType& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:types.ExtGandivaType)
                GOOGLE_DCHECK_NE(&from, this);
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        cached_has_bits = from._has_bits_[0];
        if (cached_has_bits & 0x000000ffu) {
            if (cached_has_bits & 0x00000001u) {
                _has_bits_[0] |= 0x00000001u;
                timezone_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.timezone_);
            }
            if (cached_has_bits & 0x00000002u) {
                type_ = from.type_;
            }
            if (cached_has_bits & 0x00000004u) {
                width_ = from.width_;
            }
            if (cached_has_bits & 0x00000008u) {
                precision_ = from.precision_;
            }
            if (cached_has_bits & 0x00000010u) {
                scale_ = from.scale_;
            }
            if (cached_has_bits & 0x00000020u) {
                dateunit_ = from.dateunit_;
            }
            if (cached_has_bits & 0x00000040u) {
                timeunit_ = from.timeunit_;
            }
            if (cached_has_bits & 0x00000080u) {
                intervaltype_ = from.intervaltype_;
            }
            _has_bits_[0] |= cached_has_bits;
        }
    }

    void ExtGandivaType::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:types.ExtGandivaType)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    void ExtGandivaType::CopyFrom(const ExtGandivaType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:types.ExtGandivaType)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    bool ExtGandivaType::IsInitialized() const {
        return true;
    }

    void ExtGandivaType::InternalSwap(ExtGandivaType* other) {
        using std::swap;
        _internal_metadata_.Swap(&other->_internal_metadata_);
        swap(_has_bits_[0], other->_has_bits_[0]);
        timezone_.Swap(&other->timezone_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
                       GetArenaNoVirtual());
        swap(type_, other->type_);
        swap(width_, other->width_);
        swap(precision_, other->precision_);
        swap(scale_, other->scale_);
        swap(dateunit_, other->dateunit_);
        swap(timeunit_, other->timeunit_);
        swap(intervaltype_, other->intervaltype_);
    }

    ::PROTOBUF_NAMESPACE_ID::Metadata ExtGandivaType::GetMetadata() const {
        return GetMetadataStatic();
    }


// ===================================================================

    void Field::InitAsDefaultInstance() {
        ::types::_Field_default_instance_._instance.get_mutable()->type_ = const_cast< ::types::ExtGandivaType*>(
                ::types::ExtGandivaType::internal_default_instance());
    }
    class Field::_Internal {
    public:
        using HasBits = decltype(std::declval<Field>()._has_bits_);
        static void set_has_name(HasBits* has_bits) {
            (*has_bits)[0] |= 1u;
        }
        static const ::types::ExtGandivaType& type(const Field* msg);
        static void set_has_type(HasBits* has_bits) {
            (*has_bits)[0] |= 2u;
        }
        static void set_has_nullable(HasBits* has_bits) {
            (*has_bits)[0] |= 4u;
        }
    };

    const ::types::ExtGandivaType&
    Field::_Internal::type(const Field* msg) {
        return *msg->type_;
    }
    Field::Field()
            : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
        SharedCtor();
        // @@protoc_insertion_point(constructor:types.Field)
    }
    Field::Field(const Field& from)
            : ::PROTOBUF_NAMESPACE_ID::Message(),
              _internal_metadata_(nullptr),
              _has_bits_(from._has_bits_),
              children_(from.children_) {
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
        if (from._internal_has_name()) {
            name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
        }
        if (from._internal_has_type()) {
            type_ = new ::types::ExtGandivaType(*from.type_);
        } else {
            type_ = nullptr;
        }
        nullable_ = from.nullable_;
        // @@protoc_insertion_point(copy_constructor:types.Field)
    }

    void Field::SharedCtor() {
        ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Field_Types_2eproto.base);
        name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
        ::memset(&type_, 0, static_cast<size_t>(
                                    reinterpret_cast<char*>(&nullable_) -
                                    reinterpret_cast<char*>(&type_)) + sizeof(nullable_));
    }

    Field::~Field() {
        // @@protoc_insertion_point(destructor:types.Field)
        SharedDtor();
    }

    void Field::SharedDtor() {
        name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
        if (this != internal_default_instance()) delete type_;
    }

    void Field::SetCachedSize(int size) const {
        _cached_size_.Set(size);
    }
    const Field& Field::default_instance() {
        ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Field_Types_2eproto.base);
        return *internal_default_instance();
    }


    void Field::Clear() {
// @@protoc_insertion_point(message_clear_start:types.Field)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        children_.Clear();
        cached_has_bits = _has_bits_[0];
        if (cached_has_bits & 0x00000003u) {
            if (cached_has_bits & 0x00000001u) {
                name_.ClearNonDefaultToEmptyNoArena();
            }
            if (cached_has_bits & 0x00000002u) {
                        GOOGLE_DCHECK(type_ != nullptr);
                type_->Clear();
            }
        }
        nullable_ = false;
        _has_bits_.Clear();
        _internal_metadata_.Clear();
    }

    const char* Field::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
        _Internal::HasBits has_bits{};
        while (!ctx->Done(&ptr)) {
            ::PROTOBUF_NAMESPACE_ID::uint32 tag;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
            CHK_(ptr);
            switch (tag >> 3) {
                // optional string name = 1;
                case 1:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
                        auto str = _internal_mutable_name();
                        ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
#ifndef NDEBUG
                        ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "types.Field.name");
#endif  // !NDEBUG
                        CHK_(ptr);
                    } else goto handle_unusual;
                    continue;
                    // optional .types.ExtGandivaType type = 2;
                case 2:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
                        ptr = ctx->ParseMessage(_internal_mutable_type(), ptr);
                        CHK_(ptr);
                    } else goto handle_unusual;
                    continue;
                    // optional bool nullable = 3;
                case 3:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
                        _Internal::set_has_nullable(&has_bits);
                        nullable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
                        CHK_(ptr);
                    } else goto handle_unusual;
                    continue;
                    // repeated .types.Field children = 4;
                case 4:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
                        ptr -= 1;
                        do {
                            ptr += 1;
                            ptr = ctx->ParseMessage(_internal_add_children(), ptr);
                            CHK_(ptr);
                            if (!ctx->DataAvailable(ptr)) break;
                        } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
                    } else goto handle_unusual;
                    continue;
                default: {
                    handle_unusual:
                    if ((tag & 7) == 4 || tag == 0) {
                        ctx->SetLastTag(tag);
                        goto success;
                    }
                    ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
                    CHK_(ptr != nullptr);
                    continue;
                }
            }  // switch
        }  // while
        success:
        _has_bits_.Or(has_bits);
        return ptr;
        failure:
        ptr = nullptr;
        goto success;
#undef CHK_
    }

    ::PROTOBUF_NAMESPACE_ID::uint8* Field::_InternalSerialize(
            ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
        // @@protoc_insertion_point(serialize_to_array_start:types.Field)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        cached_has_bits = _has_bits_[0];
        // optional string name = 1;
        if (cached_has_bits & 0x00000001u) {
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
                    this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
                    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                    "types.Field.name");
            target = stream->WriteStringMaybeAliased(
                    1, this->_internal_name(), target);
        }

        // optional .types.ExtGandivaType type = 2;
        if (cached_has_bits & 0x00000002u) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
            InternalWriteMessage(
                    2, _Internal::type(this), target, stream);
        }

        // optional bool nullable = 3;
        if (cached_has_bits & 0x00000004u) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_nullable(), target);
        }

        // repeated .types.Field children = 4;
        for (unsigned int i = 0,
                     n = static_cast<unsigned int>(this->_internal_children_size()); i < n; i++) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
            InternalWriteMessage(4, this->_internal_children(i), target, stream);
        }

        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
                    _internal_metadata_.unknown_fields(), target, stream);
        }
        // @@protoc_insertion_point(serialize_to_array_end:types.Field)
        return target;
    }

    size_t Field::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:types.Field)
        size_t total_size = 0;

        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        // repeated .types.Field children = 4;
        total_size += 1UL * this->_internal_children_size();
        for (const auto& msg : this->children_) {
            total_size +=
                    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
        }

        cached_has_bits = _has_bits_[0];
        if (cached_has_bits & 0x00000007u) {
            // optional string name = 1;
            if (cached_has_bits & 0x00000001u) {
                total_size += 1 +
                              ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_name());
            }

            // optional .types.ExtGandivaType type = 2;
            if (cached_has_bits & 0x00000002u) {
                total_size += 1 +
                              ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                                      *type_);
            }

            // optional bool nullable = 3;
            if (cached_has_bits & 0x00000004u) {
                total_size += 1 + 1;
            }

        }
        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
                    _internal_metadata_, total_size, &_cached_size_);
        }
        int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
        SetCachedSize(cached_size);
        return total_size;
    }

    void Field::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:types.Field)
                GOOGLE_DCHECK_NE(&from, this);
        const Field* source =
                ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Field>(
                        &from);
        if (source == nullptr) {
            // @@protoc_insertion_point(generalized_merge_from_cast_fail:types.Field)
            ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
        } else {
            // @@protoc_insertion_point(generalized_merge_from_cast_success:types.Field)
            MergeFrom(*source);
        }
    }

    void Field::MergeFrom(const Field& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:types.Field)
                GOOGLE_DCHECK_NE(&from, this);
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        children_.MergeFrom(from.children_);
        cached_has_bits = from._has_bits_[0];
        if (cached_has_bits & 0x00000007u) {
            if (cached_has_bits & 0x00000001u) {
                _has_bits_[0] |= 0x00000001u;
                name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
            }
            if (cached_has_bits & 0x00000002u) {
                _internal_mutable_type()->::types::ExtGandivaType::MergeFrom(from._internal_type());
            }
            if (cached_has_bits & 0x00000004u) {
                nullable_ = from.nullable_;
            }
            _has_bits_[0] |= cached_has_bits;
        }
    }

    void Field::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:types.Field)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    void Field::CopyFrom(const Field& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:types.Field)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    bool Field::IsInitialized() const {
        return true;
    }

    void Field::InternalSwap(Field* other) {
        using std::swap;
        _internal_metadata_.Swap(&other->_internal_metadata_);
        swap(_has_bits_[0], other->_has_bits_[0]);
        children_.InternalSwap(&other->children_);
        name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
                   GetArenaNoVirtual());
        swap(type_, other->type_);
        swap(nullable_, other->nullable_);
    }

    ::PROTOBUF_NAMESPACE_ID::Metadata Field::GetMetadata() const {
        return GetMetadataStatic();
    }


// ===================================================================

    void FieldNode::InitAsDefaultInstance() {
        ::types::_FieldNode_default_instance_._instance.get_mutable()->field_ = const_cast< ::types::Field*>(
                ::types::Field::internal_default_instance());
    }
    class FieldNode::_Internal {
    public:
        using HasBits = decltype(std::declval<FieldNode>()._has_bits_);
        static const ::types::Field& field(const FieldNode* msg);
        static void set_has_field(HasBits* has_bits) {
            (*has_bits)[0] |= 1u;
        }
    };

    const ::types::Field&
    FieldNode::_Internal::field(const FieldNode* msg) {
        return *msg->field_;
    }
    FieldNode::FieldNode()
            : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
        SharedCtor();
        // @@protoc_insertion_point(constructor:types.FieldNode)
    }
    FieldNode::FieldNode(const FieldNode& from)
            : ::PROTOBUF_NAMESPACE_ID::Message(),
              _internal_metadata_(nullptr),
              _has_bits_(from._has_bits_) {
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        if (from._internal_has_field()) {
            field_ = new ::types::Field(*from.field_);
        } else {
            field_ = nullptr;
        }
        // @@protoc_insertion_point(copy_constructor:types.FieldNode)
    }

    void FieldNode::SharedCtor() {
        ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_FieldNode_Types_2eproto.base);
        field_ = nullptr;
    }

    FieldNode::~FieldNode() {
        // @@protoc_insertion_point(destructor:types.FieldNode)
        SharedDtor();
    }

    void FieldNode::SharedDtor() {
        if (this != internal_default_instance()) delete field_;
    }

    void FieldNode::SetCachedSize(int size) const {
        _cached_size_.Set(size);
    }
    const FieldNode& FieldNode::default_instance() {
        ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_FieldNode_Types_2eproto.base);
        return *internal_default_instance();
    }


    void FieldNode::Clear() {
// @@protoc_insertion_point(message_clear_start:types.FieldNode)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        cached_has_bits = _has_bits_[0];
        if (cached_has_bits & 0x00000001u) {
                    GOOGLE_DCHECK(field_ != nullptr);
            field_->Clear();
        }
        _has_bits_.Clear();
        _internal_metadata_.Clear();
    }

    const char* FieldNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
        _Internal::HasBits has_bits{};
        while (!ctx->Done(&ptr)) {
            ::PROTOBUF_NAMESPACE_ID::uint32 tag;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
            CHK_(ptr);
            switch (tag >> 3) {
                // optional .types.Field field = 1;
                case 1:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
                        ptr = ctx->ParseMessage(_internal_mutable_field(), ptr);
                        CHK_(ptr);
                    } else goto handle_unusual;
                    continue;
                default: {
                    handle_unusual:
                    if ((tag & 7) == 4 || tag == 0) {
                        ctx->SetLastTag(tag);
                        goto success;
                    }
                    ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
                    CHK_(ptr != nullptr);
                    continue;
                }
            }  // switch
        }  // while
        success:
        _has_bits_.Or(has_bits);
        return ptr;
        failure:
        ptr = nullptr;
        goto success;
#undef CHK_
    }

    ::PROTOBUF_NAMESPACE_ID::uint8* FieldNode::_InternalSerialize(
            ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
        // @@protoc_insertion_point(serialize_to_array_start:types.FieldNode)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        cached_has_bits = _has_bits_[0];
        // optional .types.Field field = 1;
        if (cached_has_bits & 0x00000001u) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
            InternalWriteMessage(
                    1, _Internal::field(this), target, stream);
        }

        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
                    _internal_metadata_.unknown_fields(), target, stream);
        }
        // @@protoc_insertion_point(serialize_to_array_end:types.FieldNode)
        return target;
    }

    size_t FieldNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:types.FieldNode)
        size_t total_size = 0;

        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        // optional .types.Field field = 1;
        cached_has_bits = _has_bits_[0];
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 +
                          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                                  *field_);
        }

        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
                    _internal_metadata_, total_size, &_cached_size_);
        }
        int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
        SetCachedSize(cached_size);
        return total_size;
    }

    void FieldNode::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:types.FieldNode)
                GOOGLE_DCHECK_NE(&from, this);
        const FieldNode* source =
                ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<FieldNode>(
                        &from);
        if (source == nullptr) {
            // @@protoc_insertion_point(generalized_merge_from_cast_fail:types.FieldNode)
            ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
        } else {
            // @@protoc_insertion_point(generalized_merge_from_cast_success:types.FieldNode)
            MergeFrom(*source);
        }
    }

    void FieldNode::MergeFrom(const FieldNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:types.FieldNode)
                GOOGLE_DCHECK_NE(&from, this);
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        if (from._internal_has_field()) {
            _internal_mutable_field()->::types::Field::MergeFrom(from._internal_field());
        }
    }

    void FieldNode::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:types.FieldNode)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    void FieldNode::CopyFrom(const FieldNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:types.FieldNode)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    bool FieldNode::IsInitialized() const {
        return true;
    }

    void FieldNode::InternalSwap(FieldNode* other) {
        using std::swap;
        _internal_metadata_.Swap(&other->_internal_metadata_);
        swap(_has_bits_[0], other->_has_bits_[0]);
        swap(field_, other->field_);
    }

    ::PROTOBUF_NAMESPACE_ID::Metadata FieldNode::GetMetadata() const {
        return GetMetadataStatic();
    }


// ===================================================================

    void FunctionNode::InitAsDefaultInstance() {
        ::types::_FunctionNode_default_instance_._instance.get_mutable()->returntype_ = const_cast< ::types::ExtGandivaType*>(
                ::types::ExtGandivaType::internal_default_instance());
    }
    class FunctionNode::_Internal {
    public:
        using HasBits = decltype(std::declval<FunctionNode>()._has_bits_);
        static void set_has_functionname(HasBits* has_bits) {
            (*has_bits)[0] |= 1u;
        }
        static const ::types::ExtGandivaType& returntype(const FunctionNode* msg);
        static void set_has_returntype(HasBits* has_bits) {
            (*has_bits)[0] |= 2u;
        }
    };

    const ::types::ExtGandivaType&
    FunctionNode::_Internal::returntype(const FunctionNode* msg) {
        return *msg->returntype_;
    }
    FunctionNode::FunctionNode()
            : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
        SharedCtor();
        // @@protoc_insertion_point(constructor:types.FunctionNode)
    }
    FunctionNode::FunctionNode(const FunctionNode& from)
            : ::PROTOBUF_NAMESPACE_ID::Message(),
              _internal_metadata_(nullptr),
              _has_bits_(from._has_bits_),
              inargs_(from.inargs_) {
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        functionname_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
        if (from._internal_has_functionname()) {
            functionname_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.functionname_);
        }
        if (from._internal_has_returntype()) {
            returntype_ = new ::types::ExtGandivaType(*from.returntype_);
        } else {
            returntype_ = nullptr;
        }
        // @@protoc_insertion_point(copy_constructor:types.FunctionNode)
    }

    void FunctionNode::SharedCtor() {
        ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_AndNode_Types_2eproto.base);
        functionname_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
        returntype_ = nullptr;
    }

    FunctionNode::~FunctionNode() {
        // @@protoc_insertion_point(destructor:types.FunctionNode)
        SharedDtor();
    }

    void FunctionNode::SharedDtor() {
        functionname_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
        if (this != internal_default_instance()) delete returntype_;
    }

    void FunctionNode::SetCachedSize(int size) const {
        _cached_size_.Set(size);
    }
    const FunctionNode& FunctionNode::default_instance() {
        ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AndNode_Types_2eproto.base);
        return *internal_default_instance();
    }


    void FunctionNode::Clear() {
// @@protoc_insertion_point(message_clear_start:types.FunctionNode)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        inargs_.Clear();
        cached_has_bits = _has_bits_[0];
        if (cached_has_bits & 0x00000003u) {
            if (cached_has_bits & 0x00000001u) {
                functionname_.ClearNonDefaultToEmptyNoArena();
            }
            if (cached_has_bits & 0x00000002u) {
                        GOOGLE_DCHECK(returntype_ != nullptr);
                returntype_->Clear();
            }
        }
        _has_bits_.Clear();
        _internal_metadata_.Clear();
    }

    const char* FunctionNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
        _Internal::HasBits has_bits{};
        while (!ctx->Done(&ptr)) {
            ::PROTOBUF_NAMESPACE_ID::uint32 tag;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
            CHK_(ptr);
            switch (tag >> 3) {
                // optional string functionName = 1;
                case 1:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
                        auto str = _internal_mutable_functionname();
                        ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
#ifndef NDEBUG
                        ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "types.FunctionNode.functionName");
#endif  // !NDEBUG
                        CHK_(ptr);
                    } else goto handle_unusual;
                    continue;
                    // repeated .types.TreeNode inArgs = 2;
                case 2:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
                        ptr -= 1;
                        do {
                            ptr += 1;
                            ptr = ctx->ParseMessage(_internal_add_inargs(), ptr);
                            CHK_(ptr);
                            if (!ctx->DataAvailable(ptr)) break;
                        } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
                    } else goto handle_unusual;
                    continue;
                    // optional .types.ExtGandivaType returnType = 3;
                case 3:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
                        ptr = ctx->ParseMessage(_internal_mutable_returntype(), ptr);
                        CHK_(ptr);
                    } else goto handle_unusual;
                    continue;
                default: {
                    handle_unusual:
                    if ((tag & 7) == 4 || tag == 0) {
                        ctx->SetLastTag(tag);
                        goto success;
                    }
                    ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
                    CHK_(ptr != nullptr);
                    continue;
                }
            }  // switch
        }  // while
        success:
        _has_bits_.Or(has_bits);
        return ptr;
        failure:
        ptr = nullptr;
        goto success;
#undef CHK_
    }

    ::PROTOBUF_NAMESPACE_ID::uint8* FunctionNode::_InternalSerialize(
            ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
        // @@protoc_insertion_point(serialize_to_array_start:types.FunctionNode)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        cached_has_bits = _has_bits_[0];
        // optional string functionName = 1;
        if (cached_has_bits & 0x00000001u) {
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
                    this->_internal_functionname().data(), static_cast<int>(this->_internal_functionname().length()),
                    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                    "types.FunctionNode.functionName");
            target = stream->WriteStringMaybeAliased(
                    1, this->_internal_functionname(), target);
        }

        // repeated .types.TreeNode inArgs = 2;
        for (unsigned int i = 0,
                     n = static_cast<unsigned int>(this->_internal_inargs_size()); i < n; i++) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
            InternalWriteMessage(2, this->_internal_inargs(i), target, stream);
        }

        // optional .types.ExtGandivaType returnType = 3;
        if (cached_has_bits & 0x00000002u) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
            InternalWriteMessage(
                    3, _Internal::returntype(this), target, stream);
        }

        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
                    _internal_metadata_.unknown_fields(), target, stream);
        }
        // @@protoc_insertion_point(serialize_to_array_end:types.FunctionNode)
        return target;
    }

    size_t FunctionNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:types.FunctionNode)
        size_t total_size = 0;

        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        // repeated .types.TreeNode inArgs = 2;
        total_size += 1UL * this->_internal_inargs_size();
        for (const auto& msg : this->inargs_) {
            total_size +=
                    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
        }

        cached_has_bits = _has_bits_[0];
        if (cached_has_bits & 0x00000003u) {
            // optional string functionName = 1;
            if (cached_has_bits & 0x00000001u) {
                total_size += 1 +
                              ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_functionname());
            }

            // optional .types.ExtGandivaType returnType = 3;
            if (cached_has_bits & 0x00000002u) {
                total_size += 1 +
                              ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                                      *returntype_);
            }

        }
        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
                    _internal_metadata_, total_size, &_cached_size_);
        }
        int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
        SetCachedSize(cached_size);
        return total_size;
    }

    void FunctionNode::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:types.FunctionNode)
                GOOGLE_DCHECK_NE(&from, this);
        const FunctionNode* source =
                ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<FunctionNode>(
                        &from);
        if (source == nullptr) {
            // @@protoc_insertion_point(generalized_merge_from_cast_fail:types.FunctionNode)
            ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
        } else {
            // @@protoc_insertion_point(generalized_merge_from_cast_success:types.FunctionNode)
            MergeFrom(*source);
        }
    }

    void FunctionNode::MergeFrom(const FunctionNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:types.FunctionNode)
                GOOGLE_DCHECK_NE(&from, this);
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        inargs_.MergeFrom(from.inargs_);
        cached_has_bits = from._has_bits_[0];
        if (cached_has_bits & 0x00000003u) {
            if (cached_has_bits & 0x00000001u) {
                _has_bits_[0] |= 0x00000001u;
                functionname_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.functionname_);
            }
            if (cached_has_bits & 0x00000002u) {
                _internal_mutable_returntype()->::types::ExtGandivaType::MergeFrom(from._internal_returntype());
            }
        }
    }

    void FunctionNode::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:types.FunctionNode)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    void FunctionNode::CopyFrom(const FunctionNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:types.FunctionNode)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    bool FunctionNode::IsInitialized() const {
        return true;
    }

    void FunctionNode::InternalSwap(FunctionNode* other) {
        using std::swap;
        _internal_metadata_.Swap(&other->_internal_metadata_);
        swap(_has_bits_[0], other->_has_bits_[0]);
        inargs_.InternalSwap(&other->inargs_);
        functionname_.Swap(&other->functionname_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
                           GetArenaNoVirtual());
        swap(returntype_, other->returntype_);
    }

    ::PROTOBUF_NAMESPACE_ID::Metadata FunctionNode::GetMetadata() const {
        return GetMetadataStatic();
    }


// ===================================================================

    void IfNode::InitAsDefaultInstance() {
        ::types::_IfNode_default_instance_._instance.get_mutable()->cond_ = const_cast< ::types::TreeNode*>(
                ::types::TreeNode::internal_default_instance());
        ::types::_IfNode_default_instance_._instance.get_mutable()->thennode_ = const_cast< ::types::TreeNode*>(
                ::types::TreeNode::internal_default_instance());
        ::types::_IfNode_default_instance_._instance.get_mutable()->elsenode_ = const_cast< ::types::TreeNode*>(
                ::types::TreeNode::internal_default_instance());
        ::types::_IfNode_default_instance_._instance.get_mutable()->returntype_ = const_cast< ::types::ExtGandivaType*>(
                ::types::ExtGandivaType::internal_default_instance());
    }
    class IfNode::_Internal {
    public:
        using HasBits = decltype(std::declval<IfNode>()._has_bits_);
        static const ::types::TreeNode& cond(const IfNode* msg);
        static void set_has_cond(HasBits* has_bits) {
            (*has_bits)[0] |= 1u;
        }
        static const ::types::TreeNode& thennode(const IfNode* msg);
        static void set_has_thennode(HasBits* has_bits) {
            (*has_bits)[0] |= 2u;
        }
        static const ::types::TreeNode& elsenode(const IfNode* msg);
        static void set_has_elsenode(HasBits* has_bits) {
            (*has_bits)[0] |= 4u;
        }
        static const ::types::ExtGandivaType& returntype(const IfNode* msg);
        static void set_has_returntype(HasBits* has_bits) {
            (*has_bits)[0] |= 8u;
        }
    };

    const ::types::TreeNode&
    IfNode::_Internal::cond(const IfNode* msg) {
        return *msg->cond_;
    }
    const ::types::TreeNode&
    IfNode::_Internal::thennode(const IfNode* msg) {
        return *msg->thennode_;
    }
    const ::types::TreeNode&
    IfNode::_Internal::elsenode(const IfNode* msg) {
        return *msg->elsenode_;
    }
    const ::types::ExtGandivaType&
    IfNode::_Internal::returntype(const IfNode* msg) {
        return *msg->returntype_;
    }
    IfNode::IfNode()
            : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
        SharedCtor();
        // @@protoc_insertion_point(constructor:types.IfNode)
    }
    IfNode::IfNode(const IfNode& from)
            : ::PROTOBUF_NAMESPACE_ID::Message(),
              _internal_metadata_(nullptr),
              _has_bits_(from._has_bits_) {
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        if (from._internal_has_cond()) {
            cond_ = new ::types::TreeNode(*from.cond_);
        } else {
            cond_ = nullptr;
        }
        if (from._internal_has_thennode()) {
            thennode_ = new ::types::TreeNode(*from.thennode_);
        } else {
            thennode_ = nullptr;
        }
        if (from._internal_has_elsenode()) {
            elsenode_ = new ::types::TreeNode(*from.elsenode_);
        } else {
            elsenode_ = nullptr;
        }
        if (from._internal_has_returntype()) {
            returntype_ = new ::types::ExtGandivaType(*from.returntype_);
        } else {
            returntype_ = nullptr;
        }
        // @@protoc_insertion_point(copy_constructor:types.IfNode)
    }

    void IfNode::SharedCtor() {
        ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_AndNode_Types_2eproto.base);
        ::memset(&cond_, 0, static_cast<size_t>(
                                    reinterpret_cast<char*>(&returntype_) -
                                    reinterpret_cast<char*>(&cond_)) + sizeof(returntype_));
    }

    IfNode::~IfNode() {
        // @@protoc_insertion_point(destructor:types.IfNode)
        SharedDtor();
    }

    void IfNode::SharedDtor() {
        if (this != internal_default_instance()) delete cond_;
        if (this != internal_default_instance()) delete thennode_;
        if (this != internal_default_instance()) delete elsenode_;
        if (this != internal_default_instance()) delete returntype_;
    }

    void IfNode::SetCachedSize(int size) const {
        _cached_size_.Set(size);
    }
    const IfNode& IfNode::default_instance() {
        ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AndNode_Types_2eproto.base);
        return *internal_default_instance();
    }


    void IfNode::Clear() {
// @@protoc_insertion_point(message_clear_start:types.IfNode)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        cached_has_bits = _has_bits_[0];
        if (cached_has_bits & 0x0000000fu) {
            if (cached_has_bits & 0x00000001u) {
                        GOOGLE_DCHECK(cond_ != nullptr);
                cond_->Clear();
            }
            if (cached_has_bits & 0x00000002u) {
                        GOOGLE_DCHECK(thennode_ != nullptr);
                thennode_->Clear();
            }
            if (cached_has_bits & 0x00000004u) {
                        GOOGLE_DCHECK(elsenode_ != nullptr);
                elsenode_->Clear();
            }
            if (cached_has_bits & 0x00000008u) {
                        GOOGLE_DCHECK(returntype_ != nullptr);
                returntype_->Clear();
            }
        }
        _has_bits_.Clear();
        _internal_metadata_.Clear();
    }

    const char* IfNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
        _Internal::HasBits has_bits{};
        while (!ctx->Done(&ptr)) {
            ::PROTOBUF_NAMESPACE_ID::uint32 tag;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
            CHK_(ptr);
            switch (tag >> 3) {
                // optional .types.TreeNode cond = 1;
                case 1:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
                        ptr = ctx->ParseMessage(_internal_mutable_cond(), ptr);
                        CHK_(ptr);
                    } else goto handle_unusual;
                    continue;
                    // optional .types.TreeNode thenNode = 2;
                case 2:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
                        ptr = ctx->ParseMessage(_internal_mutable_thennode(), ptr);
                        CHK_(ptr);
                    } else goto handle_unusual;
                    continue;
                    // optional .types.TreeNode elseNode = 3;
                case 3:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
                        ptr = ctx->ParseMessage(_internal_mutable_elsenode(), ptr);
                        CHK_(ptr);
                    } else goto handle_unusual;
                    continue;
                    // optional .types.ExtGandivaType returnType = 4;
                case 4:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
                        ptr = ctx->ParseMessage(_internal_mutable_returntype(), ptr);
                        CHK_(ptr);
                    } else goto handle_unusual;
                    continue;
                default: {
                    handle_unusual:
                    if ((tag & 7) == 4 || tag == 0) {
                        ctx->SetLastTag(tag);
                        goto success;
                    }
                    ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
                    CHK_(ptr != nullptr);
                    continue;
                }
            }  // switch
        }  // while
        success:
        _has_bits_.Or(has_bits);
        return ptr;
        failure:
        ptr = nullptr;
        goto success;
#undef CHK_
    }

    ::PROTOBUF_NAMESPACE_ID::uint8* IfNode::_InternalSerialize(
            ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
        // @@protoc_insertion_point(serialize_to_array_start:types.IfNode)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        cached_has_bits = _has_bits_[0];
        // optional .types.TreeNode cond = 1;
        if (cached_has_bits & 0x00000001u) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
            InternalWriteMessage(
                    1, _Internal::cond(this), target, stream);
        }

        // optional .types.TreeNode thenNode = 2;
        if (cached_has_bits & 0x00000002u) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
            InternalWriteMessage(
                    2, _Internal::thennode(this), target, stream);
        }

        // optional .types.TreeNode elseNode = 3;
        if (cached_has_bits & 0x00000004u) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
            InternalWriteMessage(
                    3, _Internal::elsenode(this), target, stream);
        }

        // optional .types.ExtGandivaType returnType = 4;
        if (cached_has_bits & 0x00000008u) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
            InternalWriteMessage(
                    4, _Internal::returntype(this), target, stream);
        }

        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
                    _internal_metadata_.unknown_fields(), target, stream);
        }
        // @@protoc_insertion_point(serialize_to_array_end:types.IfNode)
        return target;
    }

    size_t IfNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:types.IfNode)
        size_t total_size = 0;

        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        cached_has_bits = _has_bits_[0];
        if (cached_has_bits & 0x0000000fu) {
            // optional .types.TreeNode cond = 1;
            if (cached_has_bits & 0x00000001u) {
                total_size += 1 +
                              ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                                      *cond_);
            }

            // optional .types.TreeNode thenNode = 2;
            if (cached_has_bits & 0x00000002u) {
                total_size += 1 +
                              ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                                      *thennode_);
            }

            // optional .types.TreeNode elseNode = 3;
            if (cached_has_bits & 0x00000004u) {
                total_size += 1 +
                              ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                                      *elsenode_);
            }

            // optional .types.ExtGandivaType returnType = 4;
            if (cached_has_bits & 0x00000008u) {
                total_size += 1 +
                              ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                                      *returntype_);
            }

        }
        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
                    _internal_metadata_, total_size, &_cached_size_);
        }
        int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
        SetCachedSize(cached_size);
        return total_size;
    }

    void IfNode::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:types.IfNode)
                GOOGLE_DCHECK_NE(&from, this);
        const IfNode* source =
                ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<IfNode>(
                        &from);
        if (source == nullptr) {
            // @@protoc_insertion_point(generalized_merge_from_cast_fail:types.IfNode)
            ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
        } else {
            // @@protoc_insertion_point(generalized_merge_from_cast_success:types.IfNode)
            MergeFrom(*source);
        }
    }

    void IfNode::MergeFrom(const IfNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:types.IfNode)
                GOOGLE_DCHECK_NE(&from, this);
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        cached_has_bits = from._has_bits_[0];
        if (cached_has_bits & 0x0000000fu) {
            if (cached_has_bits & 0x00000001u) {
                _internal_mutable_cond()->::types::TreeNode::MergeFrom(from._internal_cond());
            }
            if (cached_has_bits & 0x00000002u) {
                _internal_mutable_thennode()->::types::TreeNode::MergeFrom(from._internal_thennode());
            }
            if (cached_has_bits & 0x00000004u) {
                _internal_mutable_elsenode()->::types::TreeNode::MergeFrom(from._internal_elsenode());
            }
            if (cached_has_bits & 0x00000008u) {
                _internal_mutable_returntype()->::types::ExtGandivaType::MergeFrom(from._internal_returntype());
            }
        }
    }

    void IfNode::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:types.IfNode)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    void IfNode::CopyFrom(const IfNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:types.IfNode)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    bool IfNode::IsInitialized() const {
        return true;
    }

    void IfNode::InternalSwap(IfNode* other) {
        using std::swap;
        _internal_metadata_.Swap(&other->_internal_metadata_);
        swap(_has_bits_[0], other->_has_bits_[0]);
        swap(cond_, other->cond_);
        swap(thennode_, other->thennode_);
        swap(elsenode_, other->elsenode_);
        swap(returntype_, other->returntype_);
    }

    ::PROTOBUF_NAMESPACE_ID::Metadata IfNode::GetMetadata() const {
        return GetMetadataStatic();
    }


// ===================================================================

    void AndNode::InitAsDefaultInstance() {
    }
    class AndNode::_Internal {
    public:
        using HasBits = decltype(std::declval<AndNode>()._has_bits_);
    };

    AndNode::AndNode()
            : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
        SharedCtor();
        // @@protoc_insertion_point(constructor:types.AndNode)
    }
    AndNode::AndNode(const AndNode& from)
            : ::PROTOBUF_NAMESPACE_ID::Message(),
              _internal_metadata_(nullptr),
              _has_bits_(from._has_bits_),
              args_(from.args_) {
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        // @@protoc_insertion_point(copy_constructor:types.AndNode)
    }

    void AndNode::SharedCtor() {
        ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_AndNode_Types_2eproto.base);
    }

    AndNode::~AndNode() {
        // @@protoc_insertion_point(destructor:types.AndNode)
        SharedDtor();
    }

    void AndNode::SharedDtor() {
    }

    void AndNode::SetCachedSize(int size) const {
        _cached_size_.Set(size);
    }
    const AndNode& AndNode::default_instance() {
        ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AndNode_Types_2eproto.base);
        return *internal_default_instance();
    }


    void AndNode::Clear() {
// @@protoc_insertion_point(message_clear_start:types.AndNode)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        args_.Clear();
        _has_bits_.Clear();
        _internal_metadata_.Clear();
    }

    const char* AndNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
        while (!ctx->Done(&ptr)) {
            ::PROTOBUF_NAMESPACE_ID::uint32 tag;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
            CHK_(ptr);
            switch (tag >> 3) {
                // repeated .types.TreeNode args = 1;
                case 1:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
                        ptr -= 1;
                        do {
                            ptr += 1;
                            ptr = ctx->ParseMessage(_internal_add_args(), ptr);
                            CHK_(ptr);
                            if (!ctx->DataAvailable(ptr)) break;
                        } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
                    } else goto handle_unusual;
                    continue;
                default: {
                    handle_unusual:
                    if ((tag & 7) == 4 || tag == 0) {
                        ctx->SetLastTag(tag);
                        goto success;
                    }
                    ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
                    CHK_(ptr != nullptr);
                    continue;
                }
            }  // switch
        }  // while
        success:
        return ptr;
        failure:
        ptr = nullptr;
        goto success;
#undef CHK_
    }

    ::PROTOBUF_NAMESPACE_ID::uint8* AndNode::_InternalSerialize(
            ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
        // @@protoc_insertion_point(serialize_to_array_start:types.AndNode)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        // repeated .types.TreeNode args = 1;
        for (unsigned int i = 0,
                     n = static_cast<unsigned int>(this->_internal_args_size()); i < n; i++) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
            InternalWriteMessage(1, this->_internal_args(i), target, stream);
        }

        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
                    _internal_metadata_.unknown_fields(), target, stream);
        }
        // @@protoc_insertion_point(serialize_to_array_end:types.AndNode)
        return target;
    }

    size_t AndNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:types.AndNode)
        size_t total_size = 0;

        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        // repeated .types.TreeNode args = 1;
        total_size += 1UL * this->_internal_args_size();
        for (const auto& msg : this->args_) {
            total_size +=
                    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
        }

        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
                    _internal_metadata_, total_size, &_cached_size_);
        }
        int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
        SetCachedSize(cached_size);
        return total_size;
    }

    void AndNode::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:types.AndNode)
                GOOGLE_DCHECK_NE(&from, this);
        const AndNode* source =
                ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<AndNode>(
                        &from);
        if (source == nullptr) {
            // @@protoc_insertion_point(generalized_merge_from_cast_fail:types.AndNode)
            ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
        } else {
            // @@protoc_insertion_point(generalized_merge_from_cast_success:types.AndNode)
            MergeFrom(*source);
        }
    }

    void AndNode::MergeFrom(const AndNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:types.AndNode)
                GOOGLE_DCHECK_NE(&from, this);
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        args_.MergeFrom(from.args_);
    }

    void AndNode::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:types.AndNode)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    void AndNode::CopyFrom(const AndNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:types.AndNode)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    bool AndNode::IsInitialized() const {
        return true;
    }

    void AndNode::InternalSwap(AndNode* other) {
        using std::swap;
        _internal_metadata_.Swap(&other->_internal_metadata_);
        swap(_has_bits_[0], other->_has_bits_[0]);
        args_.InternalSwap(&other->args_);
    }

    ::PROTOBUF_NAMESPACE_ID::Metadata AndNode::GetMetadata() const {
        return GetMetadataStatic();
    }


// ===================================================================

    void OrNode::InitAsDefaultInstance() {
    }
    class OrNode::_Internal {
    public:
        using HasBits = decltype(std::declval<OrNode>()._has_bits_);
    };

    OrNode::OrNode()
            : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
        SharedCtor();
        // @@protoc_insertion_point(constructor:types.OrNode)
    }
    OrNode::OrNode(const OrNode& from)
            : ::PROTOBUF_NAMESPACE_ID::Message(),
              _internal_metadata_(nullptr),
              _has_bits_(from._has_bits_),
              args_(from.args_) {
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        // @@protoc_insertion_point(copy_constructor:types.OrNode)
    }

    void OrNode::SharedCtor() {
        ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_AndNode_Types_2eproto.base);
    }

    OrNode::~OrNode() {
        // @@protoc_insertion_point(destructor:types.OrNode)
        SharedDtor();
    }

    void OrNode::SharedDtor() {
    }

    void OrNode::SetCachedSize(int size) const {
        _cached_size_.Set(size);
    }
    const OrNode& OrNode::default_instance() {
        ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AndNode_Types_2eproto.base);
        return *internal_default_instance();
    }


    void OrNode::Clear() {
// @@protoc_insertion_point(message_clear_start:types.OrNode)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        args_.Clear();
        _has_bits_.Clear();
        _internal_metadata_.Clear();
    }

    const char* OrNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
        while (!ctx->Done(&ptr)) {
            ::PROTOBUF_NAMESPACE_ID::uint32 tag;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
            CHK_(ptr);
            switch (tag >> 3) {
                // repeated .types.TreeNode args = 1;
                case 1:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
                        ptr -= 1;
                        do {
                            ptr += 1;
                            ptr = ctx->ParseMessage(_internal_add_args(), ptr);
                            CHK_(ptr);
                            if (!ctx->DataAvailable(ptr)) break;
                        } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
                    } else goto handle_unusual;
                    continue;
                default: {
                    handle_unusual:
                    if ((tag & 7) == 4 || tag == 0) {
                        ctx->SetLastTag(tag);
                        goto success;
                    }
                    ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
                    CHK_(ptr != nullptr);
                    continue;
                }
            }  // switch
        }  // while
        success:
        return ptr;
        failure:
        ptr = nullptr;
        goto success;
#undef CHK_
    }

    ::PROTOBUF_NAMESPACE_ID::uint8* OrNode::_InternalSerialize(
            ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
        // @@protoc_insertion_point(serialize_to_array_start:types.OrNode)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        // repeated .types.TreeNode args = 1;
        for (unsigned int i = 0,
                     n = static_cast<unsigned int>(this->_internal_args_size()); i < n; i++) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
            InternalWriteMessage(1, this->_internal_args(i), target, stream);
        }

        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
                    _internal_metadata_.unknown_fields(), target, stream);
        }
        // @@protoc_insertion_point(serialize_to_array_end:types.OrNode)
        return target;
    }

    size_t OrNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:types.OrNode)
        size_t total_size = 0;

        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        // repeated .types.TreeNode args = 1;
        total_size += 1UL * this->_internal_args_size();
        for (const auto& msg : this->args_) {
            total_size +=
                    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
        }

        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
                    _internal_metadata_, total_size, &_cached_size_);
        }
        int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
        SetCachedSize(cached_size);
        return total_size;
    }

    void OrNode::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:types.OrNode)
                GOOGLE_DCHECK_NE(&from, this);
        const OrNode* source =
                ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<OrNode>(
                        &from);
        if (source == nullptr) {
            // @@protoc_insertion_point(generalized_merge_from_cast_fail:types.OrNode)
            ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
        } else {
            // @@protoc_insertion_point(generalized_merge_from_cast_success:types.OrNode)
            MergeFrom(*source);
        }
    }

    void OrNode::MergeFrom(const OrNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:types.OrNode)
                GOOGLE_DCHECK_NE(&from, this);
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        args_.MergeFrom(from.args_);
    }

    void OrNode::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:types.OrNode)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    void OrNode::CopyFrom(const OrNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:types.OrNode)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    bool OrNode::IsInitialized() const {
        return true;
    }

    void OrNode::InternalSwap(OrNode* other) {
        using std::swap;
        _internal_metadata_.Swap(&other->_internal_metadata_);
        swap(_has_bits_[0], other->_has_bits_[0]);
        args_.InternalSwap(&other->args_);
    }

    ::PROTOBUF_NAMESPACE_ID::Metadata OrNode::GetMetadata() const {
        return GetMetadataStatic();
    }


// ===================================================================

    void NullNode::InitAsDefaultInstance() {
        ::types::_NullNode_default_instance_._instance.get_mutable()->type_ = const_cast< ::types::ExtGandivaType*>(
                ::types::ExtGandivaType::internal_default_instance());
    }
    class NullNode::_Internal {
    public:
        using HasBits = decltype(std::declval<NullNode>()._has_bits_);
        static const ::types::ExtGandivaType& type(const NullNode* msg);
        static void set_has_type(HasBits* has_bits) {
            (*has_bits)[0] |= 1u;
        }
    };

    const ::types::ExtGandivaType&
    NullNode::_Internal::type(const NullNode* msg) {
        return *msg->type_;
    }
    NullNode::NullNode()
            : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
        SharedCtor();
        // @@protoc_insertion_point(constructor:types.NullNode)
    }
    NullNode::NullNode(const NullNode& from)
            : ::PROTOBUF_NAMESPACE_ID::Message(),
              _internal_metadata_(nullptr),
              _has_bits_(from._has_bits_) {
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        if (from._internal_has_type()) {
            type_ = new ::types::ExtGandivaType(*from.type_);
        } else {
            type_ = nullptr;
        }
        // @@protoc_insertion_point(copy_constructor:types.NullNode)
    }

    void NullNode::SharedCtor() {
        ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_NullNode_Types_2eproto.base);
        type_ = nullptr;
    }

    NullNode::~NullNode() {
        // @@protoc_insertion_point(destructor:types.NullNode)
        SharedDtor();
    }

    void NullNode::SharedDtor() {
        if (this != internal_default_instance()) delete type_;
    }

    void NullNode::SetCachedSize(int size) const {
        _cached_size_.Set(size);
    }
    const NullNode& NullNode::default_instance() {
        ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_NullNode_Types_2eproto.base);
        return *internal_default_instance();
    }


    void NullNode::Clear() {
// @@protoc_insertion_point(message_clear_start:types.NullNode)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        cached_has_bits = _has_bits_[0];
        if (cached_has_bits & 0x00000001u) {
                    GOOGLE_DCHECK(type_ != nullptr);
            type_->Clear();
        }
        _has_bits_.Clear();
        _internal_metadata_.Clear();
    }

    const char* NullNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
        _Internal::HasBits has_bits{};
        while (!ctx->Done(&ptr)) {
            ::PROTOBUF_NAMESPACE_ID::uint32 tag;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
            CHK_(ptr);
            switch (tag >> 3) {
                // optional .types.ExtGandivaType type = 1;
                case 1:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
                        ptr = ctx->ParseMessage(_internal_mutable_type(), ptr);
                        CHK_(ptr);
                    } else goto handle_unusual;
                    continue;
                default: {
                    handle_unusual:
                    if ((tag & 7) == 4 || tag == 0) {
                        ctx->SetLastTag(tag);
                        goto success;
                    }
                    ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
                    CHK_(ptr != nullptr);
                    continue;
                }
            }  // switch
        }  // while
        success:
        _has_bits_.Or(has_bits);
        return ptr;
        failure:
        ptr = nullptr;
        goto success;
#undef CHK_
    }

    ::PROTOBUF_NAMESPACE_ID::uint8* NullNode::_InternalSerialize(
            ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
        // @@protoc_insertion_point(serialize_to_array_start:types.NullNode)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        cached_has_bits = _has_bits_[0];
        // optional .types.ExtGandivaType type = 1;
        if (cached_has_bits & 0x00000001u) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
            InternalWriteMessage(
                    1, _Internal::type(this), target, stream);
        }

        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
                    _internal_metadata_.unknown_fields(), target, stream);
        }
        // @@protoc_insertion_point(serialize_to_array_end:types.NullNode)
        return target;
    }

    size_t NullNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:types.NullNode)
        size_t total_size = 0;

        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        // optional .types.ExtGandivaType type = 1;
        cached_has_bits = _has_bits_[0];
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 +
                          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                                  *type_);
        }

        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
                    _internal_metadata_, total_size, &_cached_size_);
        }
        int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
        SetCachedSize(cached_size);
        return total_size;
    }

    void NullNode::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:types.NullNode)
                GOOGLE_DCHECK_NE(&from, this);
        const NullNode* source =
                ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<NullNode>(
                        &from);
        if (source == nullptr) {
            // @@protoc_insertion_point(generalized_merge_from_cast_fail:types.NullNode)
            ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
        } else {
            // @@protoc_insertion_point(generalized_merge_from_cast_success:types.NullNode)
            MergeFrom(*source);
        }
    }

    void NullNode::MergeFrom(const NullNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:types.NullNode)
                GOOGLE_DCHECK_NE(&from, this);
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        if (from._internal_has_type()) {
            _internal_mutable_type()->::types::ExtGandivaType::MergeFrom(from._internal_type());
        }
    }

    void NullNode::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:types.NullNode)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    void NullNode::CopyFrom(const NullNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:types.NullNode)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    bool NullNode::IsInitialized() const {
        return true;
    }

    void NullNode::InternalSwap(NullNode* other) {
        using std::swap;
        _internal_metadata_.Swap(&other->_internal_metadata_);
        swap(_has_bits_[0], other->_has_bits_[0]);
        swap(type_, other->type_);
    }

    ::PROTOBUF_NAMESPACE_ID::Metadata NullNode::GetMetadata() const {
        return GetMetadataStatic();
    }


// ===================================================================

    void IntNode::InitAsDefaultInstance() {
    }
    class IntNode::_Internal {
    public:
        using HasBits = decltype(std::declval<IntNode>()._has_bits_);
        static void set_has_value(HasBits* has_bits) {
            (*has_bits)[0] |= 1u;
        }
    };

    IntNode::IntNode()
            : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
        SharedCtor();
        // @@protoc_insertion_point(constructor:types.IntNode)
    }
    IntNode::IntNode(const IntNode& from)
            : ::PROTOBUF_NAMESPACE_ID::Message(),
              _internal_metadata_(nullptr),
              _has_bits_(from._has_bits_) {
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        value_ = from.value_;
        // @@protoc_insertion_point(copy_constructor:types.IntNode)
    }

    void IntNode::SharedCtor() {
        value_ = 0;
    }

    IntNode::~IntNode() {
        // @@protoc_insertion_point(destructor:types.IntNode)
        SharedDtor();
    }

    void IntNode::SharedDtor() {
    }

    void IntNode::SetCachedSize(int size) const {
        _cached_size_.Set(size);
    }
    const IntNode& IntNode::default_instance() {
        ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_IntNode_Types_2eproto.base);
        return *internal_default_instance();
    }


    void IntNode::Clear() {
// @@protoc_insertion_point(message_clear_start:types.IntNode)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        value_ = 0;
        _has_bits_.Clear();
        _internal_metadata_.Clear();
    }

    const char* IntNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
        _Internal::HasBits has_bits{};
        while (!ctx->Done(&ptr)) {
            ::PROTOBUF_NAMESPACE_ID::uint32 tag;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
            CHK_(ptr);
            switch (tag >> 3) {
                // optional int32 value = 1;
                case 1:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
                        _Internal::set_has_value(&has_bits);
                        value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
                        CHK_(ptr);
                    } else goto handle_unusual;
                    continue;
                default: {
                    handle_unusual:
                    if ((tag & 7) == 4 || tag == 0) {
                        ctx->SetLastTag(tag);
                        goto success;
                    }
                    ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
                    CHK_(ptr != nullptr);
                    continue;
                }
            }  // switch
        }  // while
        success:
        _has_bits_.Or(has_bits);
        return ptr;
        failure:
        ptr = nullptr;
        goto success;
#undef CHK_
    }

    ::PROTOBUF_NAMESPACE_ID::uint8* IntNode::_InternalSerialize(
            ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
        // @@protoc_insertion_point(serialize_to_array_start:types.IntNode)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        cached_has_bits = _has_bits_[0];
        // optional int32 value = 1;
        if (cached_has_bits & 0x00000001u) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_value(), target);
        }

        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
                    _internal_metadata_.unknown_fields(), target, stream);
        }
        // @@protoc_insertion_point(serialize_to_array_end:types.IntNode)
        return target;
    }

    size_t IntNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:types.IntNode)
        size_t total_size = 0;

        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        // optional int32 value = 1;
        cached_has_bits = _has_bits_[0];
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 +
                          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
                                  this->_internal_value());
        }

        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
                    _internal_metadata_, total_size, &_cached_size_);
        }
        int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
        SetCachedSize(cached_size);
        return total_size;
    }

    void IntNode::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:types.IntNode)
                GOOGLE_DCHECK_NE(&from, this);
        const IntNode* source =
                ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<IntNode>(
                        &from);
        if (source == nullptr) {
            // @@protoc_insertion_point(generalized_merge_from_cast_fail:types.IntNode)
            ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
        } else {
            // @@protoc_insertion_point(generalized_merge_from_cast_success:types.IntNode)
            MergeFrom(*source);
        }
    }

    void IntNode::MergeFrom(const IntNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:types.IntNode)
                GOOGLE_DCHECK_NE(&from, this);
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        if (from._internal_has_value()) {
            _internal_set_value(from._internal_value());
        }
    }

    void IntNode::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:types.IntNode)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    void IntNode::CopyFrom(const IntNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:types.IntNode)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    bool IntNode::IsInitialized() const {
        return true;
    }

    void IntNode::InternalSwap(IntNode* other) {
        using std::swap;
        _internal_metadata_.Swap(&other->_internal_metadata_);
        swap(_has_bits_[0], other->_has_bits_[0]);
        swap(value_, other->value_);
    }

    ::PROTOBUF_NAMESPACE_ID::Metadata IntNode::GetMetadata() const {
        return GetMetadataStatic();
    }


// ===================================================================

    void FloatNode::InitAsDefaultInstance() {
    }
    class FloatNode::_Internal {
    public:
        using HasBits = decltype(std::declval<FloatNode>()._has_bits_);
        static void set_has_value(HasBits* has_bits) {
            (*has_bits)[0] |= 1u;
        }
    };

    FloatNode::FloatNode()
            : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
        SharedCtor();
        // @@protoc_insertion_point(constructor:types.FloatNode)
    }
    FloatNode::FloatNode(const FloatNode& from)
            : ::PROTOBUF_NAMESPACE_ID::Message(),
              _internal_metadata_(nullptr),
              _has_bits_(from._has_bits_) {
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        value_ = from.value_;
        // @@protoc_insertion_point(copy_constructor:types.FloatNode)
    }

    void FloatNode::SharedCtor() {
        value_ = 0;
    }

    FloatNode::~FloatNode() {
        // @@protoc_insertion_point(destructor:types.FloatNode)
        SharedDtor();
    }

    void FloatNode::SharedDtor() {
    }

    void FloatNode::SetCachedSize(int size) const {
        _cached_size_.Set(size);
    }
    const FloatNode& FloatNode::default_instance() {
        ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_FloatNode_Types_2eproto.base);
        return *internal_default_instance();
    }


    void FloatNode::Clear() {
// @@protoc_insertion_point(message_clear_start:types.FloatNode)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        value_ = 0;
        _has_bits_.Clear();
        _internal_metadata_.Clear();
    }

    const char* FloatNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
        _Internal::HasBits has_bits{};
        while (!ctx->Done(&ptr)) {
            ::PROTOBUF_NAMESPACE_ID::uint32 tag;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
            CHK_(ptr);
            switch (tag >> 3) {
                // optional float value = 1;
                case 1:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
                        _Internal::set_has_value(&has_bits);
                        value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
                        ptr += sizeof(float);
                    } else goto handle_unusual;
                    continue;
                default: {
                    handle_unusual:
                    if ((tag & 7) == 4 || tag == 0) {
                        ctx->SetLastTag(tag);
                        goto success;
                    }
                    ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
                    CHK_(ptr != nullptr);
                    continue;
                }
            }  // switch
        }  // while
        success:
        _has_bits_.Or(has_bits);
        return ptr;
        failure:
        ptr = nullptr;
        goto success;
#undef CHK_
    }

    ::PROTOBUF_NAMESPACE_ID::uint8* FloatNode::_InternalSerialize(
            ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
        // @@protoc_insertion_point(serialize_to_array_start:types.FloatNode)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        cached_has_bits = _has_bits_[0];
        // optional float value = 1;
        if (cached_has_bits & 0x00000001u) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_value(), target);
        }

        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
                    _internal_metadata_.unknown_fields(), target, stream);
        }
        // @@protoc_insertion_point(serialize_to_array_end:types.FloatNode)
        return target;
    }

    size_t FloatNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:types.FloatNode)
        size_t total_size = 0;

        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        // optional float value = 1;
        cached_has_bits = _has_bits_[0];
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + 4;
        }

        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
                    _internal_metadata_, total_size, &_cached_size_);
        }
        int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
        SetCachedSize(cached_size);
        return total_size;
    }

    void FloatNode::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:types.FloatNode)
                GOOGLE_DCHECK_NE(&from, this);
        const FloatNode* source =
                ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<FloatNode>(
                        &from);
        if (source == nullptr) {
            // @@protoc_insertion_point(generalized_merge_from_cast_fail:types.FloatNode)
            ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
        } else {
            // @@protoc_insertion_point(generalized_merge_from_cast_success:types.FloatNode)
            MergeFrom(*source);
        }
    }

    void FloatNode::MergeFrom(const FloatNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:types.FloatNode)
                GOOGLE_DCHECK_NE(&from, this);
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        if (from._internal_has_value()) {
            _internal_set_value(from._internal_value());
        }
    }

    void FloatNode::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:types.FloatNode)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    void FloatNode::CopyFrom(const FloatNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:types.FloatNode)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    bool FloatNode::IsInitialized() const {
        return true;
    }

    void FloatNode::InternalSwap(FloatNode* other) {
        using std::swap;
        _internal_metadata_.Swap(&other->_internal_metadata_);
        swap(_has_bits_[0], other->_has_bits_[0]);
        swap(value_, other->value_);
    }

    ::PROTOBUF_NAMESPACE_ID::Metadata FloatNode::GetMetadata() const {
        return GetMetadataStatic();
    }


// ===================================================================

    void DoubleNode::InitAsDefaultInstance() {
    }
    class DoubleNode::_Internal {
    public:
        using HasBits = decltype(std::declval<DoubleNode>()._has_bits_);
        static void set_has_value(HasBits* has_bits) {
            (*has_bits)[0] |= 1u;
        }
    };

    DoubleNode::DoubleNode()
            : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
        SharedCtor();
        // @@protoc_insertion_point(constructor:types.DoubleNode)
    }
    DoubleNode::DoubleNode(const DoubleNode& from)
            : ::PROTOBUF_NAMESPACE_ID::Message(),
              _internal_metadata_(nullptr),
              _has_bits_(from._has_bits_) {
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        value_ = from.value_;
        // @@protoc_insertion_point(copy_constructor:types.DoubleNode)
    }

    void DoubleNode::SharedCtor() {
        value_ = 0;
    }

    DoubleNode::~DoubleNode() {
        // @@protoc_insertion_point(destructor:types.DoubleNode)
        SharedDtor();
    }

    void DoubleNode::SharedDtor() {
    }

    void DoubleNode::SetCachedSize(int size) const {
        _cached_size_.Set(size);
    }
    const DoubleNode& DoubleNode::default_instance() {
        ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_DoubleNode_Types_2eproto.base);
        return *internal_default_instance();
    }


    void DoubleNode::Clear() {
// @@protoc_insertion_point(message_clear_start:types.DoubleNode)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        value_ = 0;
        _has_bits_.Clear();
        _internal_metadata_.Clear();
    }

    const char* DoubleNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
        _Internal::HasBits has_bits{};
        while (!ctx->Done(&ptr)) {
            ::PROTOBUF_NAMESPACE_ID::uint32 tag;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
            CHK_(ptr);
            switch (tag >> 3) {
                // optional double value = 1;
                case 1:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 9)) {
                        _Internal::set_has_value(&has_bits);
                        value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
                        ptr += sizeof(double);
                    } else goto handle_unusual;
                    continue;
                default: {
                    handle_unusual:
                    if ((tag & 7) == 4 || tag == 0) {
                        ctx->SetLastTag(tag);
                        goto success;
                    }
                    ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
                    CHK_(ptr != nullptr);
                    continue;
                }
            }  // switch
        }  // while
        success:
        _has_bits_.Or(has_bits);
        return ptr;
        failure:
        ptr = nullptr;
        goto success;
#undef CHK_
    }

    ::PROTOBUF_NAMESPACE_ID::uint8* DoubleNode::_InternalSerialize(
            ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
        // @@protoc_insertion_point(serialize_to_array_start:types.DoubleNode)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        cached_has_bits = _has_bits_[0];
        // optional double value = 1;
        if (cached_has_bits & 0x00000001u) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_value(), target);
        }

        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
                    _internal_metadata_.unknown_fields(), target, stream);
        }
        // @@protoc_insertion_point(serialize_to_array_end:types.DoubleNode)
        return target;
    }

    size_t DoubleNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:types.DoubleNode)
        size_t total_size = 0;

        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        // optional double value = 1;
        cached_has_bits = _has_bits_[0];
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + 8;
        }

        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
                    _internal_metadata_, total_size, &_cached_size_);
        }
        int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
        SetCachedSize(cached_size);
        return total_size;
    }

    void DoubleNode::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:types.DoubleNode)
                GOOGLE_DCHECK_NE(&from, this);
        const DoubleNode* source =
                ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<DoubleNode>(
                        &from);
        if (source == nullptr) {
            // @@protoc_insertion_point(generalized_merge_from_cast_fail:types.DoubleNode)
            ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
        } else {
            // @@protoc_insertion_point(generalized_merge_from_cast_success:types.DoubleNode)
            MergeFrom(*source);
        }
    }

    void DoubleNode::MergeFrom(const DoubleNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:types.DoubleNode)
                GOOGLE_DCHECK_NE(&from, this);
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        if (from._internal_has_value()) {
            _internal_set_value(from._internal_value());
        }
    }

    void DoubleNode::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:types.DoubleNode)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    void DoubleNode::CopyFrom(const DoubleNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:types.DoubleNode)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    bool DoubleNode::IsInitialized() const {
        return true;
    }

    void DoubleNode::InternalSwap(DoubleNode* other) {
        using std::swap;
        _internal_metadata_.Swap(&other->_internal_metadata_);
        swap(_has_bits_[0], other->_has_bits_[0]);
        swap(value_, other->value_);
    }

    ::PROTOBUF_NAMESPACE_ID::Metadata DoubleNode::GetMetadata() const {
        return GetMetadataStatic();
    }


// ===================================================================

    void BooleanNode::InitAsDefaultInstance() {
    }
    class BooleanNode::_Internal {
    public:
        using HasBits = decltype(std::declval<BooleanNode>()._has_bits_);
        static void set_has_value(HasBits* has_bits) {
            (*has_bits)[0] |= 1u;
        }
    };

    BooleanNode::BooleanNode()
            : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
        SharedCtor();
        // @@protoc_insertion_point(constructor:types.BooleanNode)
    }
    BooleanNode::BooleanNode(const BooleanNode& from)
            : ::PROTOBUF_NAMESPACE_ID::Message(),
              _internal_metadata_(nullptr),
              _has_bits_(from._has_bits_) {
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        value_ = from.value_;
        // @@protoc_insertion_point(copy_constructor:types.BooleanNode)
    }

    void BooleanNode::SharedCtor() {
        value_ = false;
    }

    BooleanNode::~BooleanNode() {
        // @@protoc_insertion_point(destructor:types.BooleanNode)
        SharedDtor();
    }

    void BooleanNode::SharedDtor() {
    }

    void BooleanNode::SetCachedSize(int size) const {
        _cached_size_.Set(size);
    }
    const BooleanNode& BooleanNode::default_instance() {
        ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_BooleanNode_Types_2eproto.base);
        return *internal_default_instance();
    }


    void BooleanNode::Clear() {
// @@protoc_insertion_point(message_clear_start:types.BooleanNode)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        value_ = false;
        _has_bits_.Clear();
        _internal_metadata_.Clear();
    }

    const char* BooleanNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
        _Internal::HasBits has_bits{};
        while (!ctx->Done(&ptr)) {
            ::PROTOBUF_NAMESPACE_ID::uint32 tag;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
            CHK_(ptr);
            switch (tag >> 3) {
                // optional bool value = 1;
                case 1:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
                        _Internal::set_has_value(&has_bits);
                        value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
                        CHK_(ptr);
                    } else goto handle_unusual;
                    continue;
                default: {
                    handle_unusual:
                    if ((tag & 7) == 4 || tag == 0) {
                        ctx->SetLastTag(tag);
                        goto success;
                    }
                    ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
                    CHK_(ptr != nullptr);
                    continue;
                }
            }  // switch
        }  // while
        success:
        _has_bits_.Or(has_bits);
        return ptr;
        failure:
        ptr = nullptr;
        goto success;
#undef CHK_
    }

    ::PROTOBUF_NAMESPACE_ID::uint8* BooleanNode::_InternalSerialize(
            ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
        // @@protoc_insertion_point(serialize_to_array_start:types.BooleanNode)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        cached_has_bits = _has_bits_[0];
        // optional bool value = 1;
        if (cached_has_bits & 0x00000001u) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_value(), target);
        }

        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
                    _internal_metadata_.unknown_fields(), target, stream);
        }
        // @@protoc_insertion_point(serialize_to_array_end:types.BooleanNode)
        return target;
    }

    size_t BooleanNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:types.BooleanNode)
        size_t total_size = 0;

        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        // optional bool value = 1;
        cached_has_bits = _has_bits_[0];
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + 1;
        }

        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
                    _internal_metadata_, total_size, &_cached_size_);
        }
        int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
        SetCachedSize(cached_size);
        return total_size;
    }

    void BooleanNode::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:types.BooleanNode)
                GOOGLE_DCHECK_NE(&from, this);
        const BooleanNode* source =
                ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<BooleanNode>(
                        &from);
        if (source == nullptr) {
            // @@protoc_insertion_point(generalized_merge_from_cast_fail:types.BooleanNode)
            ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
        } else {
            // @@protoc_insertion_point(generalized_merge_from_cast_success:types.BooleanNode)
            MergeFrom(*source);
        }
    }

    void BooleanNode::MergeFrom(const BooleanNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:types.BooleanNode)
                GOOGLE_DCHECK_NE(&from, this);
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        if (from._internal_has_value()) {
            _internal_set_value(from._internal_value());
        }
    }

    void BooleanNode::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:types.BooleanNode)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    void BooleanNode::CopyFrom(const BooleanNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:types.BooleanNode)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    bool BooleanNode::IsInitialized() const {
        return true;
    }

    void BooleanNode::InternalSwap(BooleanNode* other) {
        using std::swap;
        _internal_metadata_.Swap(&other->_internal_metadata_);
        swap(_has_bits_[0], other->_has_bits_[0]);
        swap(value_, other->value_);
    }

    ::PROTOBUF_NAMESPACE_ID::Metadata BooleanNode::GetMetadata() const {
        return GetMetadataStatic();
    }


// ===================================================================

    void LongNode::InitAsDefaultInstance() {
    }
    class LongNode::_Internal {
    public:
        using HasBits = decltype(std::declval<LongNode>()._has_bits_);
        static void set_has_value(HasBits* has_bits) {
            (*has_bits)[0] |= 1u;
        }
    };

    LongNode::LongNode()
            : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
        SharedCtor();
        // @@protoc_insertion_point(constructor:types.LongNode)
    }
    LongNode::LongNode(const LongNode& from)
            : ::PROTOBUF_NAMESPACE_ID::Message(),
              _internal_metadata_(nullptr),
              _has_bits_(from._has_bits_) {
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        value_ = from.value_;
        // @@protoc_insertion_point(copy_constructor:types.LongNode)
    }

    void LongNode::SharedCtor() {
        value_ = PROTOBUF_LONGLONG(0);
    }

    LongNode::~LongNode() {
        // @@protoc_insertion_point(destructor:types.LongNode)
        SharedDtor();
    }

    void LongNode::SharedDtor() {
    }

    void LongNode::SetCachedSize(int size) const {
        _cached_size_.Set(size);
    }
    const LongNode& LongNode::default_instance() {
        ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_LongNode_Types_2eproto.base);
        return *internal_default_instance();
    }


    void LongNode::Clear() {
// @@protoc_insertion_point(message_clear_start:types.LongNode)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        value_ = PROTOBUF_LONGLONG(0);
        _has_bits_.Clear();
        _internal_metadata_.Clear();
    }

    const char* LongNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
        _Internal::HasBits has_bits{};
        while (!ctx->Done(&ptr)) {
            ::PROTOBUF_NAMESPACE_ID::uint32 tag;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
            CHK_(ptr);
            switch (tag >> 3) {
                // optional int64 value = 1;
                case 1:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
                        _Internal::set_has_value(&has_bits);
                        value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
                        CHK_(ptr);
                    } else goto handle_unusual;
                    continue;
                default: {
                    handle_unusual:
                    if ((tag & 7) == 4 || tag == 0) {
                        ctx->SetLastTag(tag);
                        goto success;
                    }
                    ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
                    CHK_(ptr != nullptr);
                    continue;
                }
            }  // switch
        }  // while
        success:
        _has_bits_.Or(has_bits);
        return ptr;
        failure:
        ptr = nullptr;
        goto success;
#undef CHK_
    }

    ::PROTOBUF_NAMESPACE_ID::uint8* LongNode::_InternalSerialize(
            ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
        // @@protoc_insertion_point(serialize_to_array_start:types.LongNode)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        cached_has_bits = _has_bits_[0];
        // optional int64 value = 1;
        if (cached_has_bits & 0x00000001u) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_value(), target);
        }

        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
                    _internal_metadata_.unknown_fields(), target, stream);
        }
        // @@protoc_insertion_point(serialize_to_array_end:types.LongNode)
        return target;
    }

    size_t LongNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:types.LongNode)
        size_t total_size = 0;

        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        // optional int64 value = 1;
        cached_has_bits = _has_bits_[0];
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 +
                          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
                                  this->_internal_value());
        }

        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
                    _internal_metadata_, total_size, &_cached_size_);
        }
        int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
        SetCachedSize(cached_size);
        return total_size;
    }

    void LongNode::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:types.LongNode)
                GOOGLE_DCHECK_NE(&from, this);
        const LongNode* source =
                ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<LongNode>(
                        &from);
        if (source == nullptr) {
            // @@protoc_insertion_point(generalized_merge_from_cast_fail:types.LongNode)
            ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
        } else {
            // @@protoc_insertion_point(generalized_merge_from_cast_success:types.LongNode)
            MergeFrom(*source);
        }
    }

    void LongNode::MergeFrom(const LongNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:types.LongNode)
                GOOGLE_DCHECK_NE(&from, this);
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        if (from._internal_has_value()) {
            _internal_set_value(from._internal_value());
        }
    }

    void LongNode::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:types.LongNode)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    void LongNode::CopyFrom(const LongNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:types.LongNode)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    bool LongNode::IsInitialized() const {
        return true;
    }

    void LongNode::InternalSwap(LongNode* other) {
        using std::swap;
        _internal_metadata_.Swap(&other->_internal_metadata_);
        swap(_has_bits_[0], other->_has_bits_[0]);
        swap(value_, other->value_);
    }

    ::PROTOBUF_NAMESPACE_ID::Metadata LongNode::GetMetadata() const {
        return GetMetadataStatic();
    }


// ===================================================================

    void StringNode::InitAsDefaultInstance() {
    }
    class StringNode::_Internal {
    public:
        using HasBits = decltype(std::declval<StringNode>()._has_bits_);
        static void set_has_value(HasBits* has_bits) {
            (*has_bits)[0] |= 1u;
        }
    };

    StringNode::StringNode()
            : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
        SharedCtor();
        // @@protoc_insertion_point(constructor:types.StringNode)
    }
    StringNode::StringNode(const StringNode& from)
            : ::PROTOBUF_NAMESPACE_ID::Message(),
              _internal_metadata_(nullptr),
              _has_bits_(from._has_bits_) {
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
        if (from._internal_has_value()) {
            value_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.value_);
        }
        // @@protoc_insertion_point(copy_constructor:types.StringNode)
    }

    void StringNode::SharedCtor() {
        ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_StringNode_Types_2eproto.base);
        value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
    }

    StringNode::~StringNode() {
        // @@protoc_insertion_point(destructor:types.StringNode)
        SharedDtor();
    }

    void StringNode::SharedDtor() {
        value_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
    }

    void StringNode::SetCachedSize(int size) const {
        _cached_size_.Set(size);
    }
    const StringNode& StringNode::default_instance() {
        ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_StringNode_Types_2eproto.base);
        return *internal_default_instance();
    }


    void StringNode::Clear() {
// @@protoc_insertion_point(message_clear_start:types.StringNode)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        cached_has_bits = _has_bits_[0];
        if (cached_has_bits & 0x00000001u) {
            value_.ClearNonDefaultToEmptyNoArena();
        }
        _has_bits_.Clear();
        _internal_metadata_.Clear();
    }

    const char* StringNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
        _Internal::HasBits has_bits{};
        while (!ctx->Done(&ptr)) {
            ::PROTOBUF_NAMESPACE_ID::uint32 tag;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
            CHK_(ptr);
            switch (tag >> 3) {
                // optional bytes value = 1;
                case 1:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
                        auto str = _internal_mutable_value();
                        ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
                        CHK_(ptr);
                    } else goto handle_unusual;
                    continue;
                default: {
                    handle_unusual:
                    if ((tag & 7) == 4 || tag == 0) {
                        ctx->SetLastTag(tag);
                        goto success;
                    }
                    ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
                    CHK_(ptr != nullptr);
                    continue;
                }
            }  // switch
        }  // while
        success:
        _has_bits_.Or(has_bits);
        return ptr;
        failure:
        ptr = nullptr;
        goto success;
#undef CHK_
    }

    ::PROTOBUF_NAMESPACE_ID::uint8* StringNode::_InternalSerialize(
            ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
        // @@protoc_insertion_point(serialize_to_array_start:types.StringNode)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        cached_has_bits = _has_bits_[0];
        // optional bytes value = 1;
        if (cached_has_bits & 0x00000001u) {
            target = stream->WriteBytesMaybeAliased(
                    1, this->_internal_value(), target);
        }

        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
                    _internal_metadata_.unknown_fields(), target, stream);
        }
        // @@protoc_insertion_point(serialize_to_array_end:types.StringNode)
        return target;
    }

    size_t StringNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:types.StringNode)
        size_t total_size = 0;

        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        // optional bytes value = 1;
        cached_has_bits = _has_bits_[0];
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 +
                          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                  this->_internal_value());
        }

        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
                    _internal_metadata_, total_size, &_cached_size_);
        }
        int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
        SetCachedSize(cached_size);
        return total_size;
    }

    void StringNode::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:types.StringNode)
                GOOGLE_DCHECK_NE(&from, this);
        const StringNode* source =
                ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<StringNode>(
                        &from);
        if (source == nullptr) {
            // @@protoc_insertion_point(generalized_merge_from_cast_fail:types.StringNode)
            ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
        } else {
            // @@protoc_insertion_point(generalized_merge_from_cast_success:types.StringNode)
            MergeFrom(*source);
        }
    }

    void StringNode::MergeFrom(const StringNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:types.StringNode)
                GOOGLE_DCHECK_NE(&from, this);
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        if (from._internal_has_value()) {
            _has_bits_[0] |= 0x00000001u;
            value_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.value_);
        }
    }

    void StringNode::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:types.StringNode)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    void StringNode::CopyFrom(const StringNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:types.StringNode)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    bool StringNode::IsInitialized() const {
        return true;
    }

    void StringNode::InternalSwap(StringNode* other) {
        using std::swap;
        _internal_metadata_.Swap(&other->_internal_metadata_);
        swap(_has_bits_[0], other->_has_bits_[0]);
        value_.Swap(&other->value_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
                    GetArenaNoVirtual());
    }

    ::PROTOBUF_NAMESPACE_ID::Metadata StringNode::GetMetadata() const {
        return GetMetadataStatic();
    }


// ===================================================================

    void BinaryNode::InitAsDefaultInstance() {
    }
    class BinaryNode::_Internal {
    public:
        using HasBits = decltype(std::declval<BinaryNode>()._has_bits_);
        static void set_has_value(HasBits* has_bits) {
            (*has_bits)[0] |= 1u;
        }
    };

    BinaryNode::BinaryNode()
            : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
        SharedCtor();
        // @@protoc_insertion_point(constructor:types.BinaryNode)
    }
    BinaryNode::BinaryNode(const BinaryNode& from)
            : ::PROTOBUF_NAMESPACE_ID::Message(),
              _internal_metadata_(nullptr),
              _has_bits_(from._has_bits_) {
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
        if (from._internal_has_value()) {
            value_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.value_);
        }
        // @@protoc_insertion_point(copy_constructor:types.BinaryNode)
    }

    void BinaryNode::SharedCtor() {
        ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_BinaryNode_Types_2eproto.base);
        value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
    }

    BinaryNode::~BinaryNode() {
        // @@protoc_insertion_point(destructor:types.BinaryNode)
        SharedDtor();
    }

    void BinaryNode::SharedDtor() {
        value_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
    }

    void BinaryNode::SetCachedSize(int size) const {
        _cached_size_.Set(size);
    }
    const BinaryNode& BinaryNode::default_instance() {
        ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_BinaryNode_Types_2eproto.base);
        return *internal_default_instance();
    }


    void BinaryNode::Clear() {
// @@protoc_insertion_point(message_clear_start:types.BinaryNode)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        cached_has_bits = _has_bits_[0];
        if (cached_has_bits & 0x00000001u) {
            value_.ClearNonDefaultToEmptyNoArena();
        }
        _has_bits_.Clear();
        _internal_metadata_.Clear();
    }

    const char* BinaryNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
        _Internal::HasBits has_bits{};
        while (!ctx->Done(&ptr)) {
            ::PROTOBUF_NAMESPACE_ID::uint32 tag;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
            CHK_(ptr);
            switch (tag >> 3) {
                // optional bytes value = 1;
                case 1:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
                        auto str = _internal_mutable_value();
                        ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
                        CHK_(ptr);
                    } else goto handle_unusual;
                    continue;
                default: {
                    handle_unusual:
                    if ((tag & 7) == 4 || tag == 0) {
                        ctx->SetLastTag(tag);
                        goto success;
                    }
                    ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
                    CHK_(ptr != nullptr);
                    continue;
                }
            }  // switch
        }  // while
        success:
        _has_bits_.Or(has_bits);
        return ptr;
        failure:
        ptr = nullptr;
        goto success;
#undef CHK_
    }

    ::PROTOBUF_NAMESPACE_ID::uint8* BinaryNode::_InternalSerialize(
            ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
        // @@protoc_insertion_point(serialize_to_array_start:types.BinaryNode)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        cached_has_bits = _has_bits_[0];
        // optional bytes value = 1;
        if (cached_has_bits & 0x00000001u) {
            target = stream->WriteBytesMaybeAliased(
                    1, this->_internal_value(), target);
        }

        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
                    _internal_metadata_.unknown_fields(), target, stream);
        }
        // @@protoc_insertion_point(serialize_to_array_end:types.BinaryNode)
        return target;
    }

    size_t BinaryNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:types.BinaryNode)
        size_t total_size = 0;

        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        // optional bytes value = 1;
        cached_has_bits = _has_bits_[0];
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 +
                          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                  this->_internal_value());
        }

        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
                    _internal_metadata_, total_size, &_cached_size_);
        }
        int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
        SetCachedSize(cached_size);
        return total_size;
    }

    void BinaryNode::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:types.BinaryNode)
                GOOGLE_DCHECK_NE(&from, this);
        const BinaryNode* source =
                ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<BinaryNode>(
                        &from);
        if (source == nullptr) {
            // @@protoc_insertion_point(generalized_merge_from_cast_fail:types.BinaryNode)
            ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
        } else {
            // @@protoc_insertion_point(generalized_merge_from_cast_success:types.BinaryNode)
            MergeFrom(*source);
        }
    }

    void BinaryNode::MergeFrom(const BinaryNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:types.BinaryNode)
                GOOGLE_DCHECK_NE(&from, this);
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        if (from._internal_has_value()) {
            _has_bits_[0] |= 0x00000001u;
            value_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.value_);
        }
    }

    void BinaryNode::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:types.BinaryNode)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    void BinaryNode::CopyFrom(const BinaryNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:types.BinaryNode)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    bool BinaryNode::IsInitialized() const {
        return true;
    }

    void BinaryNode::InternalSwap(BinaryNode* other) {
        using std::swap;
        _internal_metadata_.Swap(&other->_internal_metadata_);
        swap(_has_bits_[0], other->_has_bits_[0]);
        value_.Swap(&other->value_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
                    GetArenaNoVirtual());
    }

    ::PROTOBUF_NAMESPACE_ID::Metadata BinaryNode::GetMetadata() const {
        return GetMetadataStatic();
    }


// ===================================================================

    void DecimalNode::InitAsDefaultInstance() {
    }
    class DecimalNode::_Internal {
    public:
        using HasBits = decltype(std::declval<DecimalNode>()._has_bits_);
        static void set_has_value(HasBits* has_bits) {
            (*has_bits)[0] |= 1u;
        }
        static void set_has_precision(HasBits* has_bits) {
            (*has_bits)[0] |= 2u;
        }
        static void set_has_scale(HasBits* has_bits) {
            (*has_bits)[0] |= 4u;
        }
    };

    DecimalNode::DecimalNode()
            : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
        SharedCtor();
        // @@protoc_insertion_point(constructor:types.DecimalNode)
    }
    DecimalNode::DecimalNode(const DecimalNode& from)
            : ::PROTOBUF_NAMESPACE_ID::Message(),
              _internal_metadata_(nullptr),
              _has_bits_(from._has_bits_) {
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
        if (from._internal_has_value()) {
            value_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.value_);
        }
        ::memcpy(&precision_, &from.precision_,
                 static_cast<size_t>(reinterpret_cast<char*>(&scale_) -
                                     reinterpret_cast<char*>(&precision_)) + sizeof(scale_));
        // @@protoc_insertion_point(copy_constructor:types.DecimalNode)
    }

    void DecimalNode::SharedCtor() {
        ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_DecimalNode_Types_2eproto.base);
        value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
        ::memset(&precision_, 0, static_cast<size_t>(
                                         reinterpret_cast<char*>(&scale_) -
                                         reinterpret_cast<char*>(&precision_)) + sizeof(scale_));
    }

    DecimalNode::~DecimalNode() {
        // @@protoc_insertion_point(destructor:types.DecimalNode)
        SharedDtor();
    }

    void DecimalNode::SharedDtor() {
        value_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
    }

    void DecimalNode::SetCachedSize(int size) const {
        _cached_size_.Set(size);
    }
    const DecimalNode& DecimalNode::default_instance() {
        ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_DecimalNode_Types_2eproto.base);
        return *internal_default_instance();
    }


    void DecimalNode::Clear() {
// @@protoc_insertion_point(message_clear_start:types.DecimalNode)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        cached_has_bits = _has_bits_[0];
        if (cached_has_bits & 0x00000001u) {
            value_.ClearNonDefaultToEmptyNoArena();
        }
        if (cached_has_bits & 0x00000006u) {
            ::memset(&precision_, 0, static_cast<size_t>(
                                             reinterpret_cast<char*>(&scale_) -
                                             reinterpret_cast<char*>(&precision_)) + sizeof(scale_));
        }
        _has_bits_.Clear();
        _internal_metadata_.Clear();
    }

    const char* DecimalNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
        _Internal::HasBits has_bits{};
        while (!ctx->Done(&ptr)) {
            ::PROTOBUF_NAMESPACE_ID::uint32 tag;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
            CHK_(ptr);
            switch (tag >> 3) {
                // optional string value = 1;
                case 1:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
                        auto str = _internal_mutable_value();
                        ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
#ifndef NDEBUG
                        ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "types.DecimalNode.value");
#endif  // !NDEBUG
                        CHK_(ptr);
                    } else goto handle_unusual;
                    continue;
                    // optional int32 precision = 2;
                case 2:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
                        _Internal::set_has_precision(&has_bits);
                        precision_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
                        CHK_(ptr);
                    } else goto handle_unusual;
                    continue;
                    // optional int32 scale = 3;
                case 3:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
                        _Internal::set_has_scale(&has_bits);
                        scale_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
                        CHK_(ptr);
                    } else goto handle_unusual;
                    continue;
                default: {
                    handle_unusual:
                    if ((tag & 7) == 4 || tag == 0) {
                        ctx->SetLastTag(tag);
                        goto success;
                    }
                    ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
                    CHK_(ptr != nullptr);
                    continue;
                }
            }  // switch
        }  // while
        success:
        _has_bits_.Or(has_bits);
        return ptr;
        failure:
        ptr = nullptr;
        goto success;
#undef CHK_
    }

    ::PROTOBUF_NAMESPACE_ID::uint8* DecimalNode::_InternalSerialize(
            ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
        // @@protoc_insertion_point(serialize_to_array_start:types.DecimalNode)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        cached_has_bits = _has_bits_[0];
        // optional string value = 1;
        if (cached_has_bits & 0x00000001u) {
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
                    this->_internal_value().data(), static_cast<int>(this->_internal_value().length()),
                    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                    "types.DecimalNode.value");
            target = stream->WriteStringMaybeAliased(
                    1, this->_internal_value(), target);
        }

        // optional int32 precision = 2;
        if (cached_has_bits & 0x00000002u) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_precision(), target);
        }

        // optional int32 scale = 3;
        if (cached_has_bits & 0x00000004u) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_scale(), target);
        }

        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
                    _internal_metadata_.unknown_fields(), target, stream);
        }
        // @@protoc_insertion_point(serialize_to_array_end:types.DecimalNode)
        return target;
    }

    size_t DecimalNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:types.DecimalNode)
        size_t total_size = 0;

        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        cached_has_bits = _has_bits_[0];
        if (cached_has_bits & 0x00000007u) {
            // optional string value = 1;
            if (cached_has_bits & 0x00000001u) {
                total_size += 1 +
                              ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_value());
            }

            // optional int32 precision = 2;
            if (cached_has_bits & 0x00000002u) {
                total_size += 1 +
                              ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
                                      this->_internal_precision());
            }

            // optional int32 scale = 3;
            if (cached_has_bits & 0x00000004u) {
                total_size += 1 +
                              ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
                                      this->_internal_scale());
            }

        }
        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
                    _internal_metadata_, total_size, &_cached_size_);
        }
        int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
        SetCachedSize(cached_size);
        return total_size;
    }

    void DecimalNode::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:types.DecimalNode)
                GOOGLE_DCHECK_NE(&from, this);
        const DecimalNode* source =
                ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<DecimalNode>(
                        &from);
        if (source == nullptr) {
            // @@protoc_insertion_point(generalized_merge_from_cast_fail:types.DecimalNode)
            ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
        } else {
            // @@protoc_insertion_point(generalized_merge_from_cast_success:types.DecimalNode)
            MergeFrom(*source);
        }
    }

    void DecimalNode::MergeFrom(const DecimalNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:types.DecimalNode)
                GOOGLE_DCHECK_NE(&from, this);
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        cached_has_bits = from._has_bits_[0];
        if (cached_has_bits & 0x00000007u) {
            if (cached_has_bits & 0x00000001u) {
                _has_bits_[0] |= 0x00000001u;
                value_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.value_);
            }
            if (cached_has_bits & 0x00000002u) {
                precision_ = from.precision_;
            }
            if (cached_has_bits & 0x00000004u) {
                scale_ = from.scale_;
            }
            _has_bits_[0] |= cached_has_bits;
        }
    }

    void DecimalNode::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:types.DecimalNode)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    void DecimalNode::CopyFrom(const DecimalNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:types.DecimalNode)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    bool DecimalNode::IsInitialized() const {
        return true;
    }

    void DecimalNode::InternalSwap(DecimalNode* other) {
        using std::swap;
        _internal_metadata_.Swap(&other->_internal_metadata_);
        swap(_has_bits_[0], other->_has_bits_[0]);
        value_.Swap(&other->value_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
                    GetArenaNoVirtual());
        swap(precision_, other->precision_);
        swap(scale_, other->scale_);
    }

    ::PROTOBUF_NAMESPACE_ID::Metadata DecimalNode::GetMetadata() const {
        return GetMetadataStatic();
    }


// ===================================================================

    void TreeNode::InitAsDefaultInstance() {
        ::types::_TreeNode_default_instance_._instance.get_mutable()->fieldnode_ = const_cast< ::types::FieldNode*>(
                ::types::FieldNode::internal_default_instance());
        ::types::_TreeNode_default_instance_._instance.get_mutable()->fnnode_ = const_cast< ::types::FunctionNode*>(
                ::types::FunctionNode::internal_default_instance());
        ::types::_TreeNode_default_instance_._instance.get_mutable()->ifnode_ = const_cast< ::types::IfNode*>(
                ::types::IfNode::internal_default_instance());
        ::types::_TreeNode_default_instance_._instance.get_mutable()->andnode_ = const_cast< ::types::AndNode*>(
                ::types::AndNode::internal_default_instance());
        ::types::_TreeNode_default_instance_._instance.get_mutable()->ornode_ = const_cast< ::types::OrNode*>(
                ::types::OrNode::internal_default_instance());
        ::types::_TreeNode_default_instance_._instance.get_mutable()->nullnode_ = const_cast< ::types::NullNode*>(
                ::types::NullNode::internal_default_instance());
        ::types::_TreeNode_default_instance_._instance.get_mutable()->intnode_ = const_cast< ::types::IntNode*>(
                ::types::IntNode::internal_default_instance());
        ::types::_TreeNode_default_instance_._instance.get_mutable()->floatnode_ = const_cast< ::types::FloatNode*>(
                ::types::FloatNode::internal_default_instance());
        ::types::_TreeNode_default_instance_._instance.get_mutable()->longnode_ = const_cast< ::types::LongNode*>(
                ::types::LongNode::internal_default_instance());
        ::types::_TreeNode_default_instance_._instance.get_mutable()->booleannode_ = const_cast< ::types::BooleanNode*>(
                ::types::BooleanNode::internal_default_instance());
        ::types::_TreeNode_default_instance_._instance.get_mutable()->doublenode_ = const_cast< ::types::DoubleNode*>(
                ::types::DoubleNode::internal_default_instance());
        ::types::_TreeNode_default_instance_._instance.get_mutable()->stringnode_ = const_cast< ::types::StringNode*>(
                ::types::StringNode::internal_default_instance());
        ::types::_TreeNode_default_instance_._instance.get_mutable()->binarynode_ = const_cast< ::types::BinaryNode*>(
                ::types::BinaryNode::internal_default_instance());
        ::types::_TreeNode_default_instance_._instance.get_mutable()->decimalnode_ = const_cast< ::types::DecimalNode*>(
                ::types::DecimalNode::internal_default_instance());
        ::types::_TreeNode_default_instance_._instance.get_mutable()->innode_ = const_cast< ::types::InNode*>(
                ::types::InNode::internal_default_instance());
    }
    class TreeNode::_Internal {
    public:
        using HasBits = decltype(std::declval<TreeNode>()._has_bits_);
        static const ::types::FieldNode& fieldnode(const TreeNode* msg);
        static void set_has_fieldnode(HasBits* has_bits) {
            (*has_bits)[0] |= 1u;
        }
        static const ::types::FunctionNode& fnnode(const TreeNode* msg);
        static void set_has_fnnode(HasBits* has_bits) {
            (*has_bits)[0] |= 2u;
        }
        static const ::types::IfNode& ifnode(const TreeNode* msg);
        static void set_has_ifnode(HasBits* has_bits) {
            (*has_bits)[0] |= 4u;
        }
        static const ::types::AndNode& andnode(const TreeNode* msg);
        static void set_has_andnode(HasBits* has_bits) {
            (*has_bits)[0] |= 8u;
        }
        static const ::types::OrNode& ornode(const TreeNode* msg);
        static void set_has_ornode(HasBits* has_bits) {
            (*has_bits)[0] |= 16u;
        }
        static const ::types::NullNode& nullnode(const TreeNode* msg);
        static void set_has_nullnode(HasBits* has_bits) {
            (*has_bits)[0] |= 32u;
        }
        static const ::types::IntNode& intnode(const TreeNode* msg);
        static void set_has_intnode(HasBits* has_bits) {
            (*has_bits)[0] |= 64u;
        }
        static const ::types::FloatNode& floatnode(const TreeNode* msg);
        static void set_has_floatnode(HasBits* has_bits) {
            (*has_bits)[0] |= 128u;
        }
        static const ::types::LongNode& longnode(const TreeNode* msg);
        static void set_has_longnode(HasBits* has_bits) {
            (*has_bits)[0] |= 256u;
        }
        static const ::types::BooleanNode& booleannode(const TreeNode* msg);
        static void set_has_booleannode(HasBits* has_bits) {
            (*has_bits)[0] |= 512u;
        }
        static const ::types::DoubleNode& doublenode(const TreeNode* msg);
        static void set_has_doublenode(HasBits* has_bits) {
            (*has_bits)[0] |= 1024u;
        }
        static const ::types::StringNode& stringnode(const TreeNode* msg);
        static void set_has_stringnode(HasBits* has_bits) {
            (*has_bits)[0] |= 2048u;
        }
        static const ::types::BinaryNode& binarynode(const TreeNode* msg);
        static void set_has_binarynode(HasBits* has_bits) {
            (*has_bits)[0] |= 4096u;
        }
        static const ::types::DecimalNode& decimalnode(const TreeNode* msg);
        static void set_has_decimalnode(HasBits* has_bits) {
            (*has_bits)[0] |= 8192u;
        }
        static const ::types::InNode& innode(const TreeNode* msg);
        static void set_has_innode(HasBits* has_bits) {
            (*has_bits)[0] |= 16384u;
        }
    };

    const ::types::FieldNode&
    TreeNode::_Internal::fieldnode(const TreeNode* msg) {
        return *msg->fieldnode_;
    }
    const ::types::FunctionNode&
    TreeNode::_Internal::fnnode(const TreeNode* msg) {
        return *msg->fnnode_;
    }
    const ::types::IfNode&
    TreeNode::_Internal::ifnode(const TreeNode* msg) {
        return *msg->ifnode_;
    }
    const ::types::AndNode&
    TreeNode::_Internal::andnode(const TreeNode* msg) {
        return *msg->andnode_;
    }
    const ::types::OrNode&
    TreeNode::_Internal::ornode(const TreeNode* msg) {
        return *msg->ornode_;
    }
    const ::types::NullNode&
    TreeNode::_Internal::nullnode(const TreeNode* msg) {
        return *msg->nullnode_;
    }
    const ::types::IntNode&
    TreeNode::_Internal::intnode(const TreeNode* msg) {
        return *msg->intnode_;
    }
    const ::types::FloatNode&
    TreeNode::_Internal::floatnode(const TreeNode* msg) {
        return *msg->floatnode_;
    }
    const ::types::LongNode&
    TreeNode::_Internal::longnode(const TreeNode* msg) {
        return *msg->longnode_;
    }
    const ::types::BooleanNode&
    TreeNode::_Internal::booleannode(const TreeNode* msg) {
        return *msg->booleannode_;
    }
    const ::types::DoubleNode&
    TreeNode::_Internal::doublenode(const TreeNode* msg) {
        return *msg->doublenode_;
    }
    const ::types::StringNode&
    TreeNode::_Internal::stringnode(const TreeNode* msg) {
        return *msg->stringnode_;
    }
    const ::types::BinaryNode&
    TreeNode::_Internal::binarynode(const TreeNode* msg) {
        return *msg->binarynode_;
    }
    const ::types::DecimalNode&
    TreeNode::_Internal::decimalnode(const TreeNode* msg) {
        return *msg->decimalnode_;
    }
    const ::types::InNode&
    TreeNode::_Internal::innode(const TreeNode* msg) {
        return *msg->innode_;
    }
    TreeNode::TreeNode()
            : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
        SharedCtor();
        // @@protoc_insertion_point(constructor:types.TreeNode)
    }
    TreeNode::TreeNode(const TreeNode& from)
            : ::PROTOBUF_NAMESPACE_ID::Message(),
              _internal_metadata_(nullptr),
              _has_bits_(from._has_bits_) {
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        if (from._internal_has_fieldnode()) {
            fieldnode_ = new ::types::FieldNode(*from.fieldnode_);
        } else {
            fieldnode_ = nullptr;
        }
        if (from._internal_has_fnnode()) {
            fnnode_ = new ::types::FunctionNode(*from.fnnode_);
        } else {
            fnnode_ = nullptr;
        }
        if (from._internal_has_ifnode()) {
            ifnode_ = new ::types::IfNode(*from.ifnode_);
        } else {
            ifnode_ = nullptr;
        }
        if (from._internal_has_andnode()) {
            andnode_ = new ::types::AndNode(*from.andnode_);
        } else {
            andnode_ = nullptr;
        }
        if (from._internal_has_ornode()) {
            ornode_ = new ::types::OrNode(*from.ornode_);
        } else {
            ornode_ = nullptr;
        }
        if (from._internal_has_nullnode()) {
            nullnode_ = new ::types::NullNode(*from.nullnode_);
        } else {
            nullnode_ = nullptr;
        }
        if (from._internal_has_intnode()) {
            intnode_ = new ::types::IntNode(*from.intnode_);
        } else {
            intnode_ = nullptr;
        }
        if (from._internal_has_floatnode()) {
            floatnode_ = new ::types::FloatNode(*from.floatnode_);
        } else {
            floatnode_ = nullptr;
        }
        if (from._internal_has_longnode()) {
            longnode_ = new ::types::LongNode(*from.longnode_);
        } else {
            longnode_ = nullptr;
        }
        if (from._internal_has_booleannode()) {
            booleannode_ = new ::types::BooleanNode(*from.booleannode_);
        } else {
            booleannode_ = nullptr;
        }
        if (from._internal_has_doublenode()) {
            doublenode_ = new ::types::DoubleNode(*from.doublenode_);
        } else {
            doublenode_ = nullptr;
        }
        if (from._internal_has_stringnode()) {
            stringnode_ = new ::types::StringNode(*from.stringnode_);
        } else {
            stringnode_ = nullptr;
        }
        if (from._internal_has_binarynode()) {
            binarynode_ = new ::types::BinaryNode(*from.binarynode_);
        } else {
            binarynode_ = nullptr;
        }
        if (from._internal_has_decimalnode()) {
            decimalnode_ = new ::types::DecimalNode(*from.decimalnode_);
        } else {
            decimalnode_ = nullptr;
        }
        if (from._internal_has_innode()) {
            innode_ = new ::types::InNode(*from.innode_);
        } else {
            innode_ = nullptr;
        }
        // @@protoc_insertion_point(copy_constructor:types.TreeNode)
    }

    void TreeNode::SharedCtor() {
        ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_AndNode_Types_2eproto.base);
        ::memset(&fieldnode_, 0, static_cast<size_t>(
                                         reinterpret_cast<char*>(&innode_) -
                                         reinterpret_cast<char*>(&fieldnode_)) + sizeof(innode_));
    }

    TreeNode::~TreeNode() {
        // @@protoc_insertion_point(destructor:types.TreeNode)
        SharedDtor();
    }

    void TreeNode::SharedDtor() {
        if (this != internal_default_instance()) delete fieldnode_;
        if (this != internal_default_instance()) delete fnnode_;
        if (this != internal_default_instance()) delete ifnode_;
        if (this != internal_default_instance()) delete andnode_;
        if (this != internal_default_instance()) delete ornode_;
        if (this != internal_default_instance()) delete nullnode_;
        if (this != internal_default_instance()) delete intnode_;
        if (this != internal_default_instance()) delete floatnode_;
        if (this != internal_default_instance()) delete longnode_;
        if (this != internal_default_instance()) delete booleannode_;
        if (this != internal_default_instance()) delete doublenode_;
        if (this != internal_default_instance()) delete stringnode_;
        if (this != internal_default_instance()) delete binarynode_;
        if (this != internal_default_instance()) delete decimalnode_;
        if (this != internal_default_instance()) delete innode_;
    }

    void TreeNode::SetCachedSize(int size) const {
        _cached_size_.Set(size);
    }
    const TreeNode& TreeNode::default_instance() {
        ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AndNode_Types_2eproto.base);
        return *internal_default_instance();
    }


    void TreeNode::Clear() {
// @@protoc_insertion_point(message_clear_start:types.TreeNode)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        cached_has_bits = _has_bits_[0];
        if (cached_has_bits & 0x000000ffu) {
            if (cached_has_bits & 0x00000001u) {
                        GOOGLE_DCHECK(fieldnode_ != nullptr);
                fieldnode_->Clear();
            }
            if (cached_has_bits & 0x00000002u) {
                        GOOGLE_DCHECK(fnnode_ != nullptr);
                fnnode_->Clear();
            }
            if (cached_has_bits & 0x00000004u) {
                        GOOGLE_DCHECK(ifnode_ != nullptr);
                ifnode_->Clear();
            }
            if (cached_has_bits & 0x00000008u) {
                        GOOGLE_DCHECK(andnode_ != nullptr);
                andnode_->Clear();
            }
            if (cached_has_bits & 0x00000010u) {
                        GOOGLE_DCHECK(ornode_ != nullptr);
                ornode_->Clear();
            }
            if (cached_has_bits & 0x00000020u) {
                        GOOGLE_DCHECK(nullnode_ != nullptr);
                nullnode_->Clear();
            }
            if (cached_has_bits & 0x00000040u) {
                        GOOGLE_DCHECK(intnode_ != nullptr);
                intnode_->Clear();
            }
            if (cached_has_bits & 0x00000080u) {
                        GOOGLE_DCHECK(floatnode_ != nullptr);
                floatnode_->Clear();
            }
        }
        if (cached_has_bits & 0x00007f00u) {
            if (cached_has_bits & 0x00000100u) {
                        GOOGLE_DCHECK(longnode_ != nullptr);
                longnode_->Clear();
            }
            if (cached_has_bits & 0x00000200u) {
                        GOOGLE_DCHECK(booleannode_ != nullptr);
                booleannode_->Clear();
            }
            if (cached_has_bits & 0x00000400u) {
                        GOOGLE_DCHECK(doublenode_ != nullptr);
                doublenode_->Clear();
            }
            if (cached_has_bits & 0x00000800u) {
                        GOOGLE_DCHECK(stringnode_ != nullptr);
                stringnode_->Clear();
            }
            if (cached_has_bits & 0x00001000u) {
                        GOOGLE_DCHECK(binarynode_ != nullptr);
                binarynode_->Clear();
            }
            if (cached_has_bits & 0x00002000u) {
                        GOOGLE_DCHECK(decimalnode_ != nullptr);
                decimalnode_->Clear();
            }
            if (cached_has_bits & 0x00004000u) {
                        GOOGLE_DCHECK(innode_ != nullptr);
                innode_->Clear();
            }
        }
        _has_bits_.Clear();
        _internal_metadata_.Clear();
    }

    const char* TreeNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
        _Internal::HasBits has_bits{};
        while (!ctx->Done(&ptr)) {
            ::PROTOBUF_NAMESPACE_ID::uint32 tag;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
            CHK_(ptr);
            switch (tag >> 3) {
                // optional .types.FieldNode fieldNode = 1;
                case 1:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
                        ptr = ctx->ParseMessage(_internal_mutable_fieldnode(), ptr);
                        CHK_(ptr);
                    } else goto handle_unusual;
                    continue;
                    // optional .types.FunctionNode fnNode = 2;
                case 2:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
                        ptr = ctx->ParseMessage(_internal_mutable_fnnode(), ptr);
                        CHK_(ptr);
                    } else goto handle_unusual;
                    continue;
                    // optional .types.IfNode ifNode = 6;
                case 6:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
                        ptr = ctx->ParseMessage(_internal_mutable_ifnode(), ptr);
                        CHK_(ptr);
                    } else goto handle_unusual;
                    continue;
                    // optional .types.AndNode andNode = 7;
                case 7:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
                        ptr = ctx->ParseMessage(_internal_mutable_andnode(), ptr);
                        CHK_(ptr);
                    } else goto handle_unusual;
                    continue;
                    // optional .types.OrNode orNode = 8;
                case 8:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
                        ptr = ctx->ParseMessage(_internal_mutable_ornode(), ptr);
                        CHK_(ptr);
                    } else goto handle_unusual;
                    continue;
                    // optional .types.NullNode nullNode = 11;
                case 11:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
                        ptr = ctx->ParseMessage(_internal_mutable_nullnode(), ptr);
                        CHK_(ptr);
                    } else goto handle_unusual;
                    continue;
                    // optional .types.IntNode intNode = 12;
                case 12:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 98)) {
                        ptr = ctx->ParseMessage(_internal_mutable_intnode(), ptr);
                        CHK_(ptr);
                    } else goto handle_unusual;
                    continue;
                    // optional .types.FloatNode floatNode = 13;
                case 13:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 106)) {
                        ptr = ctx->ParseMessage(_internal_mutable_floatnode(), ptr);
                        CHK_(ptr);
                    } else goto handle_unusual;
                    continue;
                    // optional .types.LongNode longNode = 14;
                case 14:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 114)) {
                        ptr = ctx->ParseMessage(_internal_mutable_longnode(), ptr);
                        CHK_(ptr);
                    } else goto handle_unusual;
                    continue;
                    // optional .types.BooleanNode booleanNode = 15;
                case 15:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 122)) {
                        ptr = ctx->ParseMessage(_internal_mutable_booleannode(), ptr);
                        CHK_(ptr);
                    } else goto handle_unusual;
                    continue;
                    // optional .types.DoubleNode doubleNode = 16;
                case 16:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 130)) {
                        ptr = ctx->ParseMessage(_internal_mutable_doublenode(), ptr);
                        CHK_(ptr);
                    } else goto handle_unusual;
                    continue;
                    // optional .types.StringNode stringNode = 17;
                case 17:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 138)) {
                        ptr = ctx->ParseMessage(_internal_mutable_stringnode(), ptr);
                        CHK_(ptr);
                    } else goto handle_unusual;
                    continue;
                    // optional .types.BinaryNode binaryNode = 18;
                case 18:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 146)) {
                        ptr = ctx->ParseMessage(_internal_mutable_binarynode(), ptr);
                        CHK_(ptr);
                    } else goto handle_unusual;
                    continue;
                    // optional .types.DecimalNode decimalNode = 19;
                case 19:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 154)) {
                        ptr = ctx->ParseMessage(_internal_mutable_decimalnode(), ptr);
                        CHK_(ptr);
                    } else goto handle_unusual;
                    continue;
                    // optional .types.InNode inNode = 21;
                case 21:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 170)) {
                        ptr = ctx->ParseMessage(_internal_mutable_innode(), ptr);
                        CHK_(ptr);
                    } else goto handle_unusual;
                    continue;
                default: {
                    handle_unusual:
                    if ((tag & 7) == 4 || tag == 0) {
                        ctx->SetLastTag(tag);
                        goto success;
                    }
                    ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
                    CHK_(ptr != nullptr);
                    continue;
                }
            }  // switch
        }  // while
        success:
        _has_bits_.Or(has_bits);
        return ptr;
        failure:
        ptr = nullptr;
        goto success;
#undef CHK_
    }

    ::PROTOBUF_NAMESPACE_ID::uint8* TreeNode::_InternalSerialize(
            ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
        // @@protoc_insertion_point(serialize_to_array_start:types.TreeNode)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        cached_has_bits = _has_bits_[0];
        // optional .types.FieldNode fieldNode = 1;
        if (cached_has_bits & 0x00000001u) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
            InternalWriteMessage(
                    1, _Internal::fieldnode(this), target, stream);
        }

        // optional .types.FunctionNode fnNode = 2;
        if (cached_has_bits & 0x00000002u) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
            InternalWriteMessage(
                    2, _Internal::fnnode(this), target, stream);
        }

        // optional .types.IfNode ifNode = 6;
        if (cached_has_bits & 0x00000004u) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
            InternalWriteMessage(
                    6, _Internal::ifnode(this), target, stream);
        }

        // optional .types.AndNode andNode = 7;
        if (cached_has_bits & 0x00000008u) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
            InternalWriteMessage(
                    7, _Internal::andnode(this), target, stream);
        }

        // optional .types.OrNode orNode = 8;
        if (cached_has_bits & 0x00000010u) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
            InternalWriteMessage(
                    8, _Internal::ornode(this), target, stream);
        }

        // optional .types.NullNode nullNode = 11;
        if (cached_has_bits & 0x00000020u) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
            InternalWriteMessage(
                    11, _Internal::nullnode(this), target, stream);
        }

        // optional .types.IntNode intNode = 12;
        if (cached_has_bits & 0x00000040u) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
            InternalWriteMessage(
                    12, _Internal::intnode(this), target, stream);
        }

        // optional .types.FloatNode floatNode = 13;
        if (cached_has_bits & 0x00000080u) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
            InternalWriteMessage(
                    13, _Internal::floatnode(this), target, stream);
        }

        // optional .types.LongNode longNode = 14;
        if (cached_has_bits & 0x00000100u) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
            InternalWriteMessage(
                    14, _Internal::longnode(this), target, stream);
        }

        // optional .types.BooleanNode booleanNode = 15;
        if (cached_has_bits & 0x00000200u) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
            InternalWriteMessage(
                    15, _Internal::booleannode(this), target, stream);
        }

        // optional .types.DoubleNode doubleNode = 16;
        if (cached_has_bits & 0x00000400u) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
            InternalWriteMessage(
                    16, _Internal::doublenode(this), target, stream);
        }

        // optional .types.StringNode stringNode = 17;
        if (cached_has_bits & 0x00000800u) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
            InternalWriteMessage(
                    17, _Internal::stringnode(this), target, stream);
        }

        // optional .types.BinaryNode binaryNode = 18;
        if (cached_has_bits & 0x00001000u) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
            InternalWriteMessage(
                    18, _Internal::binarynode(this), target, stream);
        }

        // optional .types.DecimalNode decimalNode = 19;
        if (cached_has_bits & 0x00002000u) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
            InternalWriteMessage(
                    19, _Internal::decimalnode(this), target, stream);
        }

        // optional .types.InNode inNode = 21;
        if (cached_has_bits & 0x00004000u) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
            InternalWriteMessage(
                    21, _Internal::innode(this), target, stream);
        }

        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
                    _internal_metadata_.unknown_fields(), target, stream);
        }
        // @@protoc_insertion_point(serialize_to_array_end:types.TreeNode)
        return target;
    }

    size_t TreeNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:types.TreeNode)
        size_t total_size = 0;

        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        cached_has_bits = _has_bits_[0];
        if (cached_has_bits & 0x000000ffu) {
            // optional .types.FieldNode fieldNode = 1;
            if (cached_has_bits & 0x00000001u) {
                total_size += 1 +
                              ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                                      *fieldnode_);
            }

            // optional .types.FunctionNode fnNode = 2;
            if (cached_has_bits & 0x00000002u) {
                total_size += 1 +
                              ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                                      *fnnode_);
            }

            // optional .types.IfNode ifNode = 6;
            if (cached_has_bits & 0x00000004u) {
                total_size += 1 +
                              ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                                      *ifnode_);
            }

            // optional .types.AndNode andNode = 7;
            if (cached_has_bits & 0x00000008u) {
                total_size += 1 +
                              ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                                      *andnode_);
            }

            // optional .types.OrNode orNode = 8;
            if (cached_has_bits & 0x00000010u) {
                total_size += 1 +
                              ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                                      *ornode_);
            }

            // optional .types.NullNode nullNode = 11;
            if (cached_has_bits & 0x00000020u) {
                total_size += 1 +
                              ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                                      *nullnode_);
            }

            // optional .types.IntNode intNode = 12;
            if (cached_has_bits & 0x00000040u) {
                total_size += 1 +
                              ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                                      *intnode_);
            }

            // optional .types.FloatNode floatNode = 13;
            if (cached_has_bits & 0x00000080u) {
                total_size += 1 +
                              ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                                      *floatnode_);
            }

        }
        if (cached_has_bits & 0x00007f00u) {
            // optional .types.LongNode longNode = 14;
            if (cached_has_bits & 0x00000100u) {
                total_size += 1 +
                              ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                                      *longnode_);
            }

            // optional .types.BooleanNode booleanNode = 15;
            if (cached_has_bits & 0x00000200u) {
                total_size += 1 +
                              ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                                      *booleannode_);
            }

            // optional .types.DoubleNode doubleNode = 16;
            if (cached_has_bits & 0x00000400u) {
                total_size += 2 +
                              ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                                      *doublenode_);
            }

            // optional .types.StringNode stringNode = 17;
            if (cached_has_bits & 0x00000800u) {
                total_size += 2 +
                              ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                                      *stringnode_);
            }

            // optional .types.BinaryNode binaryNode = 18;
            if (cached_has_bits & 0x00001000u) {
                total_size += 2 +
                              ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                                      *binarynode_);
            }

            // optional .types.DecimalNode decimalNode = 19;
            if (cached_has_bits & 0x00002000u) {
                total_size += 2 +
                              ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                                      *decimalnode_);
            }

            // optional .types.InNode inNode = 21;
            if (cached_has_bits & 0x00004000u) {
                total_size += 2 +
                              ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                                      *innode_);
            }

        }
        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
                    _internal_metadata_, total_size, &_cached_size_);
        }
        int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
        SetCachedSize(cached_size);
        return total_size;
    }

    void TreeNode::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:types.TreeNode)
                GOOGLE_DCHECK_NE(&from, this);
        const TreeNode* source =
                ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TreeNode>(
                        &from);
        if (source == nullptr) {
            // @@protoc_insertion_point(generalized_merge_from_cast_fail:types.TreeNode)
            ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
        } else {
            // @@protoc_insertion_point(generalized_merge_from_cast_success:types.TreeNode)
            MergeFrom(*source);
        }
    }

    void TreeNode::MergeFrom(const TreeNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:types.TreeNode)
                GOOGLE_DCHECK_NE(&from, this);
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        cached_has_bits = from._has_bits_[0];
        if (cached_has_bits & 0x000000ffu) {
            if (cached_has_bits & 0x00000001u) {
                _internal_mutable_fieldnode()->::types::FieldNode::MergeFrom(from._internal_fieldnode());
            }
            if (cached_has_bits & 0x00000002u) {
                _internal_mutable_fnnode()->::types::FunctionNode::MergeFrom(from._internal_fnnode());
            }
            if (cached_has_bits & 0x00000004u) {
                _internal_mutable_ifnode()->::types::IfNode::MergeFrom(from._internal_ifnode());
            }
            if (cached_has_bits & 0x00000008u) {
                _internal_mutable_andnode()->::types::AndNode::MergeFrom(from._internal_andnode());
            }
            if (cached_has_bits & 0x00000010u) {
                _internal_mutable_ornode()->::types::OrNode::MergeFrom(from._internal_ornode());
            }
            if (cached_has_bits & 0x00000020u) {
                _internal_mutable_nullnode()->::types::NullNode::MergeFrom(from._internal_nullnode());
            }
            if (cached_has_bits & 0x00000040u) {
                _internal_mutable_intnode()->::types::IntNode::MergeFrom(from._internal_intnode());
            }
            if (cached_has_bits & 0x00000080u) {
                _internal_mutable_floatnode()->::types::FloatNode::MergeFrom(from._internal_floatnode());
            }
        }
        if (cached_has_bits & 0x00007f00u) {
            if (cached_has_bits & 0x00000100u) {
                _internal_mutable_longnode()->::types::LongNode::MergeFrom(from._internal_longnode());
            }
            if (cached_has_bits & 0x00000200u) {
                _internal_mutable_booleannode()->::types::BooleanNode::MergeFrom(from._internal_booleannode());
            }
            if (cached_has_bits & 0x00000400u) {
                _internal_mutable_doublenode()->::types::DoubleNode::MergeFrom(from._internal_doublenode());
            }
            if (cached_has_bits & 0x00000800u) {
                _internal_mutable_stringnode()->::types::StringNode::MergeFrom(from._internal_stringnode());
            }
            if (cached_has_bits & 0x00001000u) {
                _internal_mutable_binarynode()->::types::BinaryNode::MergeFrom(from._internal_binarynode());
            }
            if (cached_has_bits & 0x00002000u) {
                _internal_mutable_decimalnode()->::types::DecimalNode::MergeFrom(from._internal_decimalnode());
            }
            if (cached_has_bits & 0x00004000u) {
                _internal_mutable_innode()->::types::InNode::MergeFrom(from._internal_innode());
            }
        }
    }

    void TreeNode::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:types.TreeNode)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    void TreeNode::CopyFrom(const TreeNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:types.TreeNode)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    bool TreeNode::IsInitialized() const {
        return true;
    }

    void TreeNode::InternalSwap(TreeNode* other) {
        using std::swap;
        _internal_metadata_.Swap(&other->_internal_metadata_);
        swap(_has_bits_[0], other->_has_bits_[0]);
        swap(fieldnode_, other->fieldnode_);
        swap(fnnode_, other->fnnode_);
        swap(ifnode_, other->ifnode_);
        swap(andnode_, other->andnode_);
        swap(ornode_, other->ornode_);
        swap(nullnode_, other->nullnode_);
        swap(intnode_, other->intnode_);
        swap(floatnode_, other->floatnode_);
        swap(longnode_, other->longnode_);
        swap(booleannode_, other->booleannode_);
        swap(doublenode_, other->doublenode_);
        swap(stringnode_, other->stringnode_);
        swap(binarynode_, other->binarynode_);
        swap(decimalnode_, other->decimalnode_);
        swap(innode_, other->innode_);
    }

    ::PROTOBUF_NAMESPACE_ID::Metadata TreeNode::GetMetadata() const {
        return GetMetadataStatic();
    }


// ===================================================================

    void ExpressionRoot::InitAsDefaultInstance() {
        ::types::_ExpressionRoot_default_instance_._instance.get_mutable()->root_ = const_cast< ::types::TreeNode*>(
                ::types::TreeNode::internal_default_instance());
        ::types::_ExpressionRoot_default_instance_._instance.get_mutable()->resulttype_ = const_cast< ::types::Field*>(
                ::types::Field::internal_default_instance());
    }
    class ExpressionRoot::_Internal {
    public:
        using HasBits = decltype(std::declval<ExpressionRoot>()._has_bits_);
        static const ::types::TreeNode& root(const ExpressionRoot* msg);
        static void set_has_root(HasBits* has_bits) {
            (*has_bits)[0] |= 1u;
        }
        static const ::types::Field& resulttype(const ExpressionRoot* msg);
        static void set_has_resulttype(HasBits* has_bits) {
            (*has_bits)[0] |= 2u;
        }
    };

    const ::types::TreeNode&
    ExpressionRoot::_Internal::root(const ExpressionRoot* msg) {
        return *msg->root_;
    }
    const ::types::Field&
    ExpressionRoot::_Internal::resulttype(const ExpressionRoot* msg) {
        return *msg->resulttype_;
    }
    ExpressionRoot::ExpressionRoot()
            : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
        SharedCtor();
        // @@protoc_insertion_point(constructor:types.ExpressionRoot)
    }
    ExpressionRoot::ExpressionRoot(const ExpressionRoot& from)
            : ::PROTOBUF_NAMESPACE_ID::Message(),
              _internal_metadata_(nullptr),
              _has_bits_(from._has_bits_) {
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        if (from._internal_has_root()) {
            root_ = new ::types::TreeNode(*from.root_);
        } else {
            root_ = nullptr;
        }
        if (from._internal_has_resulttype()) {
            resulttype_ = new ::types::Field(*from.resulttype_);
        } else {
            resulttype_ = nullptr;
        }
        // @@protoc_insertion_point(copy_constructor:types.ExpressionRoot)
    }

    void ExpressionRoot::SharedCtor() {
        ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ExpressionRoot_Types_2eproto.base);
        ::memset(&root_, 0, static_cast<size_t>(
                                    reinterpret_cast<char*>(&resulttype_) -
                                    reinterpret_cast<char*>(&root_)) + sizeof(resulttype_));
    }

    ExpressionRoot::~ExpressionRoot() {
        // @@protoc_insertion_point(destructor:types.ExpressionRoot)
        SharedDtor();
    }

    void ExpressionRoot::SharedDtor() {
        if (this != internal_default_instance()) delete root_;
        if (this != internal_default_instance()) delete resulttype_;
    }

    void ExpressionRoot::SetCachedSize(int size) const {
        _cached_size_.Set(size);
    }
    const ExpressionRoot& ExpressionRoot::default_instance() {
        ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ExpressionRoot_Types_2eproto.base);
        return *internal_default_instance();
    }


    void ExpressionRoot::Clear() {
// @@protoc_insertion_point(message_clear_start:types.ExpressionRoot)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        cached_has_bits = _has_bits_[0];
        if (cached_has_bits & 0x00000003u) {
            if (cached_has_bits & 0x00000001u) {
                        GOOGLE_DCHECK(root_ != nullptr);
                root_->Clear();
            }
            if (cached_has_bits & 0x00000002u) {
                        GOOGLE_DCHECK(resulttype_ != nullptr);
                resulttype_->Clear();
            }
        }
        _has_bits_.Clear();
        _internal_metadata_.Clear();
    }

    const char* ExpressionRoot::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
        _Internal::HasBits has_bits{};
        while (!ctx->Done(&ptr)) {
            ::PROTOBUF_NAMESPACE_ID::uint32 tag;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
            CHK_(ptr);
            switch (tag >> 3) {
                // optional .types.TreeNode root = 1;
                case 1:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
                        ptr = ctx->ParseMessage(_internal_mutable_root(), ptr);
                        CHK_(ptr);
                    } else goto handle_unusual;
                    continue;
                    // optional .types.Field resultType = 2;
                case 2:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
                        ptr = ctx->ParseMessage(_internal_mutable_resulttype(), ptr);
                        CHK_(ptr);
                    } else goto handle_unusual;
                    continue;
                default: {
                    handle_unusual:
                    if ((tag & 7) == 4 || tag == 0) {
                        ctx->SetLastTag(tag);
                        goto success;
                    }
                    ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
                    CHK_(ptr != nullptr);
                    continue;
                }
            }  // switch
        }  // while
        success:
        _has_bits_.Or(has_bits);
        return ptr;
        failure:
        ptr = nullptr;
        goto success;
#undef CHK_
    }

    ::PROTOBUF_NAMESPACE_ID::uint8* ExpressionRoot::_InternalSerialize(
            ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
        // @@protoc_insertion_point(serialize_to_array_start:types.ExpressionRoot)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        cached_has_bits = _has_bits_[0];
        // optional .types.TreeNode root = 1;
        if (cached_has_bits & 0x00000001u) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
            InternalWriteMessage(
                    1, _Internal::root(this), target, stream);
        }

        // optional .types.Field resultType = 2;
        if (cached_has_bits & 0x00000002u) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
            InternalWriteMessage(
                    2, _Internal::resulttype(this), target, stream);
        }

        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
                    _internal_metadata_.unknown_fields(), target, stream);
        }
        // @@protoc_insertion_point(serialize_to_array_end:types.ExpressionRoot)
        return target;
    }

    size_t ExpressionRoot::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:types.ExpressionRoot)
        size_t total_size = 0;

        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        cached_has_bits = _has_bits_[0];
        if (cached_has_bits & 0x00000003u) {
            // optional .types.TreeNode root = 1;
            if (cached_has_bits & 0x00000001u) {
                total_size += 1 +
                              ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                                      *root_);
            }

            // optional .types.Field resultType = 2;
            if (cached_has_bits & 0x00000002u) {
                total_size += 1 +
                              ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                                      *resulttype_);
            }

        }
        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
                    _internal_metadata_, total_size, &_cached_size_);
        }
        int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
        SetCachedSize(cached_size);
        return total_size;
    }

    void ExpressionRoot::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:types.ExpressionRoot)
                GOOGLE_DCHECK_NE(&from, this);
        const ExpressionRoot* source =
                ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ExpressionRoot>(
                        &from);
        if (source == nullptr) {
            // @@protoc_insertion_point(generalized_merge_from_cast_fail:types.ExpressionRoot)
            ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
        } else {
            // @@protoc_insertion_point(generalized_merge_from_cast_success:types.ExpressionRoot)
            MergeFrom(*source);
        }
    }

    void ExpressionRoot::MergeFrom(const ExpressionRoot& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:types.ExpressionRoot)
                GOOGLE_DCHECK_NE(&from, this);
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        cached_has_bits = from._has_bits_[0];
        if (cached_has_bits & 0x00000003u) {
            if (cached_has_bits & 0x00000001u) {
                _internal_mutable_root()->::types::TreeNode::MergeFrom(from._internal_root());
            }
            if (cached_has_bits & 0x00000002u) {
                _internal_mutable_resulttype()->::types::Field::MergeFrom(from._internal_resulttype());
            }
        }
    }

    void ExpressionRoot::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:types.ExpressionRoot)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    void ExpressionRoot::CopyFrom(const ExpressionRoot& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:types.ExpressionRoot)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    bool ExpressionRoot::IsInitialized() const {
        return true;
    }

    void ExpressionRoot::InternalSwap(ExpressionRoot* other) {
        using std::swap;
        _internal_metadata_.Swap(&other->_internal_metadata_);
        swap(_has_bits_[0], other->_has_bits_[0]);
        swap(root_, other->root_);
        swap(resulttype_, other->resulttype_);
    }

    ::PROTOBUF_NAMESPACE_ID::Metadata ExpressionRoot::GetMetadata() const {
        return GetMetadataStatic();
    }


// ===================================================================

    void ExpressionList::InitAsDefaultInstance() {
    }
    class ExpressionList::_Internal {
    public:
        using HasBits = decltype(std::declval<ExpressionList>()._has_bits_);
    };

    ExpressionList::ExpressionList()
            : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
        SharedCtor();
        // @@protoc_insertion_point(constructor:types.ExpressionList)
    }
    ExpressionList::ExpressionList(const ExpressionList& from)
            : ::PROTOBUF_NAMESPACE_ID::Message(),
              _internal_metadata_(nullptr),
              _has_bits_(from._has_bits_),
              exprs_(from.exprs_) {
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        // @@protoc_insertion_point(copy_constructor:types.ExpressionList)
    }

    void ExpressionList::SharedCtor() {
        ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ExpressionList_Types_2eproto.base);
    }

    ExpressionList::~ExpressionList() {
        // @@protoc_insertion_point(destructor:types.ExpressionList)
        SharedDtor();
    }

    void ExpressionList::SharedDtor() {
    }

    void ExpressionList::SetCachedSize(int size) const {
        _cached_size_.Set(size);
    }
    const ExpressionList& ExpressionList::default_instance() {
        ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ExpressionList_Types_2eproto.base);
        return *internal_default_instance();
    }


    void ExpressionList::Clear() {
// @@protoc_insertion_point(message_clear_start:types.ExpressionList)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        exprs_.Clear();
        _has_bits_.Clear();
        _internal_metadata_.Clear();
    }

    const char* ExpressionList::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
        while (!ctx->Done(&ptr)) {
            ::PROTOBUF_NAMESPACE_ID::uint32 tag;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
            CHK_(ptr);
            switch (tag >> 3) {
                // repeated .types.ExpressionRoot exprs = 2;
                case 2:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
                        ptr -= 1;
                        do {
                            ptr += 1;
                            ptr = ctx->ParseMessage(_internal_add_exprs(), ptr);
                            CHK_(ptr);
                            if (!ctx->DataAvailable(ptr)) break;
                        } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
                    } else goto handle_unusual;
                    continue;
                default: {
                    handle_unusual:
                    if ((tag & 7) == 4 || tag == 0) {
                        ctx->SetLastTag(tag);
                        goto success;
                    }
                    ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
                    CHK_(ptr != nullptr);
                    continue;
                }
            }  // switch
        }  // while
        success:
        return ptr;
        failure:
        ptr = nullptr;
        goto success;
#undef CHK_
    }

    ::PROTOBUF_NAMESPACE_ID::uint8* ExpressionList::_InternalSerialize(
            ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
        // @@protoc_insertion_point(serialize_to_array_start:types.ExpressionList)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        // repeated .types.ExpressionRoot exprs = 2;
        for (unsigned int i = 0,
                     n = static_cast<unsigned int>(this->_internal_exprs_size()); i < n; i++) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
            InternalWriteMessage(2, this->_internal_exprs(i), target, stream);
        }

        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
                    _internal_metadata_.unknown_fields(), target, stream);
        }
        // @@protoc_insertion_point(serialize_to_array_end:types.ExpressionList)
        return target;
    }

    size_t ExpressionList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:types.ExpressionList)
        size_t total_size = 0;

        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        // repeated .types.ExpressionRoot exprs = 2;
        total_size += 1UL * this->_internal_exprs_size();
        for (const auto& msg : this->exprs_) {
            total_size +=
                    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
        }

        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
                    _internal_metadata_, total_size, &_cached_size_);
        }
        int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
        SetCachedSize(cached_size);
        return total_size;
    }

    void ExpressionList::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:types.ExpressionList)
                GOOGLE_DCHECK_NE(&from, this);
        const ExpressionList* source =
                ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ExpressionList>(
                        &from);
        if (source == nullptr) {
            // @@protoc_insertion_point(generalized_merge_from_cast_fail:types.ExpressionList)
            ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
        } else {
            // @@protoc_insertion_point(generalized_merge_from_cast_success:types.ExpressionList)
            MergeFrom(*source);
        }
    }

    void ExpressionList::MergeFrom(const ExpressionList& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:types.ExpressionList)
                GOOGLE_DCHECK_NE(&from, this);
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        exprs_.MergeFrom(from.exprs_);
    }

    void ExpressionList::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:types.ExpressionList)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    void ExpressionList::CopyFrom(const ExpressionList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:types.ExpressionList)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    bool ExpressionList::IsInitialized() const {
        return true;
    }

    void ExpressionList::InternalSwap(ExpressionList* other) {
        using std::swap;
        _internal_metadata_.Swap(&other->_internal_metadata_);
        swap(_has_bits_[0], other->_has_bits_[0]);
        exprs_.InternalSwap(&other->exprs_);
    }

    ::PROTOBUF_NAMESPACE_ID::Metadata ExpressionList::GetMetadata() const {
        return GetMetadataStatic();
    }


// ===================================================================

    void Condition::InitAsDefaultInstance() {
        ::types::_Condition_default_instance_._instance.get_mutable()->root_ = const_cast< ::types::TreeNode*>(
                ::types::TreeNode::internal_default_instance());
    }
    class Condition::_Internal {
    public:
        using HasBits = decltype(std::declval<Condition>()._has_bits_);
        static const ::types::TreeNode& root(const Condition* msg);
        static void set_has_root(HasBits* has_bits) {
            (*has_bits)[0] |= 1u;
        }
    };

    const ::types::TreeNode&
    Condition::_Internal::root(const Condition* msg) {
        return *msg->root_;
    }
    Condition::Condition()
            : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
        SharedCtor();
        // @@protoc_insertion_point(constructor:types.Condition)
    }
    Condition::Condition(const Condition& from)
            : ::PROTOBUF_NAMESPACE_ID::Message(),
              _internal_metadata_(nullptr),
              _has_bits_(from._has_bits_) {
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        if (from._internal_has_root()) {
            root_ = new ::types::TreeNode(*from.root_);
        } else {
            root_ = nullptr;
        }
        // @@protoc_insertion_point(copy_constructor:types.Condition)
    }

    void Condition::SharedCtor() {
        ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Condition_Types_2eproto.base);
        root_ = nullptr;
    }

    Condition::~Condition() {
        // @@protoc_insertion_point(destructor:types.Condition)
        SharedDtor();
    }

    void Condition::SharedDtor() {
        if (this != internal_default_instance()) delete root_;
    }

    void Condition::SetCachedSize(int size) const {
        _cached_size_.Set(size);
    }
    const Condition& Condition::default_instance() {
        ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Condition_Types_2eproto.base);
        return *internal_default_instance();
    }


    void Condition::Clear() {
// @@protoc_insertion_point(message_clear_start:types.Condition)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        cached_has_bits = _has_bits_[0];
        if (cached_has_bits & 0x00000001u) {
                    GOOGLE_DCHECK(root_ != nullptr);
            root_->Clear();
        }
        _has_bits_.Clear();
        _internal_metadata_.Clear();
    }

    const char* Condition::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
        _Internal::HasBits has_bits{};
        while (!ctx->Done(&ptr)) {
            ::PROTOBUF_NAMESPACE_ID::uint32 tag;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
            CHK_(ptr);
            switch (tag >> 3) {
                // optional .types.TreeNode root = 1;
                case 1:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
                        ptr = ctx->ParseMessage(_internal_mutable_root(), ptr);
                        CHK_(ptr);
                    } else goto handle_unusual;
                    continue;
                default: {
                    handle_unusual:
                    if ((tag & 7) == 4 || tag == 0) {
                        ctx->SetLastTag(tag);
                        goto success;
                    }
                    ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
                    CHK_(ptr != nullptr);
                    continue;
                }
            }  // switch
        }  // while
        success:
        _has_bits_.Or(has_bits);
        return ptr;
        failure:
        ptr = nullptr;
        goto success;
#undef CHK_
    }

    ::PROTOBUF_NAMESPACE_ID::uint8* Condition::_InternalSerialize(
            ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
        // @@protoc_insertion_point(serialize_to_array_start:types.Condition)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        cached_has_bits = _has_bits_[0];
        // optional .types.TreeNode root = 1;
        if (cached_has_bits & 0x00000001u) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
            InternalWriteMessage(
                    1, _Internal::root(this), target, stream);
        }

        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
                    _internal_metadata_.unknown_fields(), target, stream);
        }
        // @@protoc_insertion_point(serialize_to_array_end:types.Condition)
        return target;
    }

    size_t Condition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:types.Condition)
        size_t total_size = 0;

        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        // optional .types.TreeNode root = 1;
        cached_has_bits = _has_bits_[0];
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 +
                          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                                  *root_);
        }

        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
                    _internal_metadata_, total_size, &_cached_size_);
        }
        int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
        SetCachedSize(cached_size);
        return total_size;
    }

    void Condition::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:types.Condition)
                GOOGLE_DCHECK_NE(&from, this);
        const Condition* source =
                ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Condition>(
                        &from);
        if (source == nullptr) {
            // @@protoc_insertion_point(generalized_merge_from_cast_fail:types.Condition)
            ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
        } else {
            // @@protoc_insertion_point(generalized_merge_from_cast_success:types.Condition)
            MergeFrom(*source);
        }
    }

    void Condition::MergeFrom(const Condition& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:types.Condition)
                GOOGLE_DCHECK_NE(&from, this);
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        if (from._internal_has_root()) {
            _internal_mutable_root()->::types::TreeNode::MergeFrom(from._internal_root());
        }
    }

    void Condition::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:types.Condition)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    void Condition::CopyFrom(const Condition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:types.Condition)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    bool Condition::IsInitialized() const {
        return true;
    }

    void Condition::InternalSwap(Condition* other) {
        using std::swap;
        _internal_metadata_.Swap(&other->_internal_metadata_);
        swap(_has_bits_[0], other->_has_bits_[0]);
        swap(root_, other->root_);
    }

    ::PROTOBUF_NAMESPACE_ID::Metadata Condition::GetMetadata() const {
        return GetMetadataStatic();
    }


// ===================================================================

    void Schema::InitAsDefaultInstance() {
    }
    class Schema::_Internal {
    public:
        using HasBits = decltype(std::declval<Schema>()._has_bits_);
    };

    Schema::Schema()
            : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
        SharedCtor();
        // @@protoc_insertion_point(constructor:types.Schema)
    }
    Schema::Schema(const Schema& from)
            : ::PROTOBUF_NAMESPACE_ID::Message(),
              _internal_metadata_(nullptr),
              _has_bits_(from._has_bits_),
              columns_(from.columns_) {
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        // @@protoc_insertion_point(copy_constructor:types.Schema)
    }

    void Schema::SharedCtor() {
        ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Schema_Types_2eproto.base);
    }

    Schema::~Schema() {
        // @@protoc_insertion_point(destructor:types.Schema)
        SharedDtor();
    }

    void Schema::SharedDtor() {
    }

    void Schema::SetCachedSize(int size) const {
        _cached_size_.Set(size);
    }
    const Schema& Schema::default_instance() {
        ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Schema_Types_2eproto.base);
        return *internal_default_instance();
    }


    void Schema::Clear() {
// @@protoc_insertion_point(message_clear_start:types.Schema)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        columns_.Clear();
        _has_bits_.Clear();
        _internal_metadata_.Clear();
    }

    const char* Schema::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
        while (!ctx->Done(&ptr)) {
            ::PROTOBUF_NAMESPACE_ID::uint32 tag;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
            CHK_(ptr);
            switch (tag >> 3) {
                // repeated .types.Field columns = 1;
                case 1:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
                        ptr -= 1;
                        do {
                            ptr += 1;
                            ptr = ctx->ParseMessage(_internal_add_columns(), ptr);
                            CHK_(ptr);
                            if (!ctx->DataAvailable(ptr)) break;
                        } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
                    } else goto handle_unusual;
                    continue;
                default: {
                    handle_unusual:
                    if ((tag & 7) == 4 || tag == 0) {
                        ctx->SetLastTag(tag);
                        goto success;
                    }
                    ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
                    CHK_(ptr != nullptr);
                    continue;
                }
            }  // switch
        }  // while
        success:
        return ptr;
        failure:
        ptr = nullptr;
        goto success;
#undef CHK_
    }

    ::PROTOBUF_NAMESPACE_ID::uint8* Schema::_InternalSerialize(
            ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
        // @@protoc_insertion_point(serialize_to_array_start:types.Schema)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        // repeated .types.Field columns = 1;
        for (unsigned int i = 0,
                     n = static_cast<unsigned int>(this->_internal_columns_size()); i < n; i++) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
            InternalWriteMessage(1, this->_internal_columns(i), target, stream);
        }

        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
                    _internal_metadata_.unknown_fields(), target, stream);
        }
        // @@protoc_insertion_point(serialize_to_array_end:types.Schema)
        return target;
    }

    size_t Schema::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:types.Schema)
        size_t total_size = 0;

        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        // repeated .types.Field columns = 1;
        total_size += 1UL * this->_internal_columns_size();
        for (const auto& msg : this->columns_) {
            total_size +=
                    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
        }

        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
                    _internal_metadata_, total_size, &_cached_size_);
        }
        int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
        SetCachedSize(cached_size);
        return total_size;
    }

    void Schema::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:types.Schema)
                GOOGLE_DCHECK_NE(&from, this);
        const Schema* source =
                ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Schema>(
                        &from);
        if (source == nullptr) {
            // @@protoc_insertion_point(generalized_merge_from_cast_fail:types.Schema)
            ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
        } else {
            // @@protoc_insertion_point(generalized_merge_from_cast_success:types.Schema)
            MergeFrom(*source);
        }
    }

    void Schema::MergeFrom(const Schema& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:types.Schema)
                GOOGLE_DCHECK_NE(&from, this);
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        columns_.MergeFrom(from.columns_);
    }

    void Schema::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:types.Schema)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    void Schema::CopyFrom(const Schema& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:types.Schema)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    bool Schema::IsInitialized() const {
        return true;
    }

    void Schema::InternalSwap(Schema* other) {
        using std::swap;
        _internal_metadata_.Swap(&other->_internal_metadata_);
        swap(_has_bits_[0], other->_has_bits_[0]);
        columns_.InternalSwap(&other->columns_);
    }

    ::PROTOBUF_NAMESPACE_ID::Metadata Schema::GetMetadata() const {
        return GetMetadataStatic();
    }


// ===================================================================

    void GandivaDataTypes::InitAsDefaultInstance() {
    }
    class GandivaDataTypes::_Internal {
    public:
        using HasBits = decltype(std::declval<GandivaDataTypes>()._has_bits_);
    };

    GandivaDataTypes::GandivaDataTypes()
            : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
        SharedCtor();
        // @@protoc_insertion_point(constructor:types.GandivaDataTypes)
    }
    GandivaDataTypes::GandivaDataTypes(const GandivaDataTypes& from)
            : ::PROTOBUF_NAMESPACE_ID::Message(),
              _internal_metadata_(nullptr),
              _has_bits_(from._has_bits_),
              datatype_(from.datatype_) {
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        // @@protoc_insertion_point(copy_constructor:types.GandivaDataTypes)
    }

    void GandivaDataTypes::SharedCtor() {
        ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_GandivaDataTypes_Types_2eproto.base);
    }

    GandivaDataTypes::~GandivaDataTypes() {
        // @@protoc_insertion_point(destructor:types.GandivaDataTypes)
        SharedDtor();
    }

    void GandivaDataTypes::SharedDtor() {
    }

    void GandivaDataTypes::SetCachedSize(int size) const {
        _cached_size_.Set(size);
    }
    const GandivaDataTypes& GandivaDataTypes::default_instance() {
        ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_GandivaDataTypes_Types_2eproto.base);
        return *internal_default_instance();
    }


    void GandivaDataTypes::Clear() {
// @@protoc_insertion_point(message_clear_start:types.GandivaDataTypes)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        datatype_.Clear();
        _has_bits_.Clear();
        _internal_metadata_.Clear();
    }

    const char* GandivaDataTypes::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
        while (!ctx->Done(&ptr)) {
            ::PROTOBUF_NAMESPACE_ID::uint32 tag;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
            CHK_(ptr);
            switch (tag >> 3) {
                // repeated .types.ExtGandivaType dataType = 1;
                case 1:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
                        ptr -= 1;
                        do {
                            ptr += 1;
                            ptr = ctx->ParseMessage(_internal_add_datatype(), ptr);
                            CHK_(ptr);
                            if (!ctx->DataAvailable(ptr)) break;
                        } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
                    } else goto handle_unusual;
                    continue;
                default: {
                    handle_unusual:
                    if ((tag & 7) == 4 || tag == 0) {
                        ctx->SetLastTag(tag);
                        goto success;
                    }
                    ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
                    CHK_(ptr != nullptr);
                    continue;
                }
            }  // switch
        }  // while
        success:
        return ptr;
        failure:
        ptr = nullptr;
        goto success;
#undef CHK_
    }

    ::PROTOBUF_NAMESPACE_ID::uint8* GandivaDataTypes::_InternalSerialize(
            ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
        // @@protoc_insertion_point(serialize_to_array_start:types.GandivaDataTypes)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        // repeated .types.ExtGandivaType dataType = 1;
        for (unsigned int i = 0,
                     n = static_cast<unsigned int>(this->_internal_datatype_size()); i < n; i++) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
            InternalWriteMessage(1, this->_internal_datatype(i), target, stream);
        }

        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
                    _internal_metadata_.unknown_fields(), target, stream);
        }
        // @@protoc_insertion_point(serialize_to_array_end:types.GandivaDataTypes)
        return target;
    }

    size_t GandivaDataTypes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:types.GandivaDataTypes)
        size_t total_size = 0;

        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        // repeated .types.ExtGandivaType dataType = 1;
        total_size += 1UL * this->_internal_datatype_size();
        for (const auto& msg : this->datatype_) {
            total_size +=
                    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
        }

        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
                    _internal_metadata_, total_size, &_cached_size_);
        }
        int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
        SetCachedSize(cached_size);
        return total_size;
    }

    void GandivaDataTypes::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:types.GandivaDataTypes)
                GOOGLE_DCHECK_NE(&from, this);
        const GandivaDataTypes* source =
                ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<GandivaDataTypes>(
                        &from);
        if (source == nullptr) {
            // @@protoc_insertion_point(generalized_merge_from_cast_fail:types.GandivaDataTypes)
            ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
        } else {
            // @@protoc_insertion_point(generalized_merge_from_cast_success:types.GandivaDataTypes)
            MergeFrom(*source);
        }
    }

    void GandivaDataTypes::MergeFrom(const GandivaDataTypes& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:types.GandivaDataTypes)
                GOOGLE_DCHECK_NE(&from, this);
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        datatype_.MergeFrom(from.datatype_);
    }

    void GandivaDataTypes::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:types.GandivaDataTypes)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    void GandivaDataTypes::CopyFrom(const GandivaDataTypes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:types.GandivaDataTypes)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    bool GandivaDataTypes::IsInitialized() const {
        return true;
    }

    void GandivaDataTypes::InternalSwap(GandivaDataTypes* other) {
        using std::swap;
        _internal_metadata_.Swap(&other->_internal_metadata_);
        swap(_has_bits_[0], other->_has_bits_[0]);
        datatype_.InternalSwap(&other->datatype_);
    }

    ::PROTOBUF_NAMESPACE_ID::Metadata GandivaDataTypes::GetMetadata() const {
        return GetMetadataStatic();
    }


// ===================================================================

    void GandivaFunctions::InitAsDefaultInstance() {
    }
    class GandivaFunctions::_Internal {
    public:
        using HasBits = decltype(std::declval<GandivaFunctions>()._has_bits_);
    };

    GandivaFunctions::GandivaFunctions()
            : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
        SharedCtor();
        // @@protoc_insertion_point(constructor:types.GandivaFunctions)
    }
    GandivaFunctions::GandivaFunctions(const GandivaFunctions& from)
            : ::PROTOBUF_NAMESPACE_ID::Message(),
              _internal_metadata_(nullptr),
              _has_bits_(from._has_bits_),
              function_(from.function_) {
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        // @@protoc_insertion_point(copy_constructor:types.GandivaFunctions)
    }

    void GandivaFunctions::SharedCtor() {
        ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_GandivaFunctions_Types_2eproto.base);
    }

    GandivaFunctions::~GandivaFunctions() {
        // @@protoc_insertion_point(destructor:types.GandivaFunctions)
        SharedDtor();
    }

    void GandivaFunctions::SharedDtor() {
    }

    void GandivaFunctions::SetCachedSize(int size) const {
        _cached_size_.Set(size);
    }
    const GandivaFunctions& GandivaFunctions::default_instance() {
        ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_GandivaFunctions_Types_2eproto.base);
        return *internal_default_instance();
    }


    void GandivaFunctions::Clear() {
// @@protoc_insertion_point(message_clear_start:types.GandivaFunctions)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        function_.Clear();
        _has_bits_.Clear();
        _internal_metadata_.Clear();
    }

    const char* GandivaFunctions::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
        while (!ctx->Done(&ptr)) {
            ::PROTOBUF_NAMESPACE_ID::uint32 tag;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
            CHK_(ptr);
            switch (tag >> 3) {
                // repeated .types.FunctionSignature function = 1;
                case 1:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
                        ptr -= 1;
                        do {
                            ptr += 1;
                            ptr = ctx->ParseMessage(_internal_add_function(), ptr);
                            CHK_(ptr);
                            if (!ctx->DataAvailable(ptr)) break;
                        } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
                    } else goto handle_unusual;
                    continue;
                default: {
                    handle_unusual:
                    if ((tag & 7) == 4 || tag == 0) {
                        ctx->SetLastTag(tag);
                        goto success;
                    }
                    ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
                    CHK_(ptr != nullptr);
                    continue;
                }
            }  // switch
        }  // while
        success:
        return ptr;
        failure:
        ptr = nullptr;
        goto success;
#undef CHK_
    }

    ::PROTOBUF_NAMESPACE_ID::uint8* GandivaFunctions::_InternalSerialize(
            ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
        // @@protoc_insertion_point(serialize_to_array_start:types.GandivaFunctions)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        // repeated .types.FunctionSignature function = 1;
        for (unsigned int i = 0,
                     n = static_cast<unsigned int>(this->_internal_function_size()); i < n; i++) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
            InternalWriteMessage(1, this->_internal_function(i), target, stream);
        }

        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
                    _internal_metadata_.unknown_fields(), target, stream);
        }
        // @@protoc_insertion_point(serialize_to_array_end:types.GandivaFunctions)
        return target;
    }

    size_t GandivaFunctions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:types.GandivaFunctions)
        size_t total_size = 0;

        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        // repeated .types.FunctionSignature function = 1;
        total_size += 1UL * this->_internal_function_size();
        for (const auto& msg : this->function_) {
            total_size +=
                    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
        }

        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
                    _internal_metadata_, total_size, &_cached_size_);
        }
        int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
        SetCachedSize(cached_size);
        return total_size;
    }

    void GandivaFunctions::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:types.GandivaFunctions)
                GOOGLE_DCHECK_NE(&from, this);
        const GandivaFunctions* source =
                ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<GandivaFunctions>(
                        &from);
        if (source == nullptr) {
            // @@protoc_insertion_point(generalized_merge_from_cast_fail:types.GandivaFunctions)
            ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
        } else {
            // @@protoc_insertion_point(generalized_merge_from_cast_success:types.GandivaFunctions)
            MergeFrom(*source);
        }
    }

    void GandivaFunctions::MergeFrom(const GandivaFunctions& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:types.GandivaFunctions)
                GOOGLE_DCHECK_NE(&from, this);
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        function_.MergeFrom(from.function_);
    }

    void GandivaFunctions::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:types.GandivaFunctions)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    void GandivaFunctions::CopyFrom(const GandivaFunctions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:types.GandivaFunctions)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    bool GandivaFunctions::IsInitialized() const {
        return true;
    }

    void GandivaFunctions::InternalSwap(GandivaFunctions* other) {
        using std::swap;
        _internal_metadata_.Swap(&other->_internal_metadata_);
        swap(_has_bits_[0], other->_has_bits_[0]);
        function_.InternalSwap(&other->function_);
    }

    ::PROTOBUF_NAMESPACE_ID::Metadata GandivaFunctions::GetMetadata() const {
        return GetMetadataStatic();
    }


// ===================================================================

    void FunctionSignature::InitAsDefaultInstance() {
        ::types::_FunctionSignature_default_instance_._instance.get_mutable()->returntype_ = const_cast< ::types::ExtGandivaType*>(
                ::types::ExtGandivaType::internal_default_instance());
    }
    class FunctionSignature::_Internal {
    public:
        using HasBits = decltype(std::declval<FunctionSignature>()._has_bits_);
        static void set_has_name(HasBits* has_bits) {
            (*has_bits)[0] |= 1u;
        }
        static const ::types::ExtGandivaType& returntype(const FunctionSignature* msg);
        static void set_has_returntype(HasBits* has_bits) {
            (*has_bits)[0] |= 2u;
        }
    };

    const ::types::ExtGandivaType&
    FunctionSignature::_Internal::returntype(const FunctionSignature* msg) {
        return *msg->returntype_;
    }
    FunctionSignature::FunctionSignature()
            : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
        SharedCtor();
        // @@protoc_insertion_point(constructor:types.FunctionSignature)
    }
    FunctionSignature::FunctionSignature(const FunctionSignature& from)
            : ::PROTOBUF_NAMESPACE_ID::Message(),
              _internal_metadata_(nullptr),
              _has_bits_(from._has_bits_),
              paramtypes_(from.paramtypes_) {
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
        if (from._internal_has_name()) {
            name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
        }
        if (from._internal_has_returntype()) {
            returntype_ = new ::types::ExtGandivaType(*from.returntype_);
        } else {
            returntype_ = nullptr;
        }
        // @@protoc_insertion_point(copy_constructor:types.FunctionSignature)
    }

    void FunctionSignature::SharedCtor() {
        ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_FunctionSignature_Types_2eproto.base);
        name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
        returntype_ = nullptr;
    }

    FunctionSignature::~FunctionSignature() {
        // @@protoc_insertion_point(destructor:types.FunctionSignature)
        SharedDtor();
    }

    void FunctionSignature::SharedDtor() {
        name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
        if (this != internal_default_instance()) delete returntype_;
    }

    void FunctionSignature::SetCachedSize(int size) const {
        _cached_size_.Set(size);
    }
    const FunctionSignature& FunctionSignature::default_instance() {
        ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_FunctionSignature_Types_2eproto.base);
        return *internal_default_instance();
    }


    void FunctionSignature::Clear() {
// @@protoc_insertion_point(message_clear_start:types.FunctionSignature)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        paramtypes_.Clear();
        cached_has_bits = _has_bits_[0];
        if (cached_has_bits & 0x00000003u) {
            if (cached_has_bits & 0x00000001u) {
                name_.ClearNonDefaultToEmptyNoArena();
            }
            if (cached_has_bits & 0x00000002u) {
                        GOOGLE_DCHECK(returntype_ != nullptr);
                returntype_->Clear();
            }
        }
        _has_bits_.Clear();
        _internal_metadata_.Clear();
    }

    const char* FunctionSignature::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
        _Internal::HasBits has_bits{};
        while (!ctx->Done(&ptr)) {
            ::PROTOBUF_NAMESPACE_ID::uint32 tag;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
            CHK_(ptr);
            switch (tag >> 3) {
                // optional string name = 1;
                case 1:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
                        auto str = _internal_mutable_name();
                        ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
#ifndef NDEBUG
                        ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "types.FunctionSignature.name");
#endif  // !NDEBUG
                        CHK_(ptr);
                    } else goto handle_unusual;
                    continue;
                    // optional .types.ExtGandivaType returnType = 2;
                case 2:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
                        ptr = ctx->ParseMessage(_internal_mutable_returntype(), ptr);
                        CHK_(ptr);
                    } else goto handle_unusual;
                    continue;
                    // repeated .types.ExtGandivaType paramTypes = 3;
                case 3:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
                        ptr -= 1;
                        do {
                            ptr += 1;
                            ptr = ctx->ParseMessage(_internal_add_paramtypes(), ptr);
                            CHK_(ptr);
                            if (!ctx->DataAvailable(ptr)) break;
                        } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
                    } else goto handle_unusual;
                    continue;
                default: {
                    handle_unusual:
                    if ((tag & 7) == 4 || tag == 0) {
                        ctx->SetLastTag(tag);
                        goto success;
                    }
                    ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
                    CHK_(ptr != nullptr);
                    continue;
                }
            }  // switch
        }  // while
        success:
        _has_bits_.Or(has_bits);
        return ptr;
        failure:
        ptr = nullptr;
        goto success;
#undef CHK_
    }

    ::PROTOBUF_NAMESPACE_ID::uint8* FunctionSignature::_InternalSerialize(
            ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
        // @@protoc_insertion_point(serialize_to_array_start:types.FunctionSignature)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        cached_has_bits = _has_bits_[0];
        // optional string name = 1;
        if (cached_has_bits & 0x00000001u) {
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
                    this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
                    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                    "types.FunctionSignature.name");
            target = stream->WriteStringMaybeAliased(
                    1, this->_internal_name(), target);
        }

        // optional .types.ExtGandivaType returnType = 2;
        if (cached_has_bits & 0x00000002u) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
            InternalWriteMessage(
                    2, _Internal::returntype(this), target, stream);
        }

        // repeated .types.ExtGandivaType paramTypes = 3;
        for (unsigned int i = 0,
                     n = static_cast<unsigned int>(this->_internal_paramtypes_size()); i < n; i++) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
            InternalWriteMessage(3, this->_internal_paramtypes(i), target, stream);
        }

        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
                    _internal_metadata_.unknown_fields(), target, stream);
        }
        // @@protoc_insertion_point(serialize_to_array_end:types.FunctionSignature)
        return target;
    }

    size_t FunctionSignature::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:types.FunctionSignature)
        size_t total_size = 0;

        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        // repeated .types.ExtGandivaType paramTypes = 3;
        total_size += 1UL * this->_internal_paramtypes_size();
        for (const auto& msg : this->paramtypes_) {
            total_size +=
                    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
        }

        cached_has_bits = _has_bits_[0];
        if (cached_has_bits & 0x00000003u) {
            // optional string name = 1;
            if (cached_has_bits & 0x00000001u) {
                total_size += 1 +
                              ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_name());
            }

            // optional .types.ExtGandivaType returnType = 2;
            if (cached_has_bits & 0x00000002u) {
                total_size += 1 +
                              ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                                      *returntype_);
            }

        }
        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
                    _internal_metadata_, total_size, &_cached_size_);
        }
        int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
        SetCachedSize(cached_size);
        return total_size;
    }

    void FunctionSignature::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:types.FunctionSignature)
                GOOGLE_DCHECK_NE(&from, this);
        const FunctionSignature* source =
                ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<FunctionSignature>(
                        &from);
        if (source == nullptr) {
            // @@protoc_insertion_point(generalized_merge_from_cast_fail:types.FunctionSignature)
            ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
        } else {
            // @@protoc_insertion_point(generalized_merge_from_cast_success:types.FunctionSignature)
            MergeFrom(*source);
        }
    }

    void FunctionSignature::MergeFrom(const FunctionSignature& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:types.FunctionSignature)
                GOOGLE_DCHECK_NE(&from, this);
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        paramtypes_.MergeFrom(from.paramtypes_);
        cached_has_bits = from._has_bits_[0];
        if (cached_has_bits & 0x00000003u) {
            if (cached_has_bits & 0x00000001u) {
                _has_bits_[0] |= 0x00000001u;
                name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
            }
            if (cached_has_bits & 0x00000002u) {
                _internal_mutable_returntype()->::types::ExtGandivaType::MergeFrom(from._internal_returntype());
            }
        }
    }

    void FunctionSignature::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:types.FunctionSignature)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    void FunctionSignature::CopyFrom(const FunctionSignature& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:types.FunctionSignature)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    bool FunctionSignature::IsInitialized() const {
        return true;
    }

    void FunctionSignature::InternalSwap(FunctionSignature* other) {
        using std::swap;
        _internal_metadata_.Swap(&other->_internal_metadata_);
        swap(_has_bits_[0], other->_has_bits_[0]);
        paramtypes_.InternalSwap(&other->paramtypes_);
        name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
                   GetArenaNoVirtual());
        swap(returntype_, other->returntype_);
    }

    ::PROTOBUF_NAMESPACE_ID::Metadata FunctionSignature::GetMetadata() const {
        return GetMetadataStatic();
    }


// ===================================================================

    void InNode::InitAsDefaultInstance() {
        ::types::_InNode_default_instance_._instance.get_mutable()->field_ = const_cast< ::types::FieldNode*>(
                ::types::FieldNode::internal_default_instance());
        ::types::_InNode_default_instance_._instance.get_mutable()->intvalues_ = const_cast< ::types::IntConstants*>(
                ::types::IntConstants::internal_default_instance());
        ::types::_InNode_default_instance_._instance.get_mutable()->longvalues_ = const_cast< ::types::LongConstants*>(
                ::types::LongConstants::internal_default_instance());
        ::types::_InNode_default_instance_._instance.get_mutable()->stringvalues_ = const_cast< ::types::StringConstants*>(
                ::types::StringConstants::internal_default_instance());
        ::types::_InNode_default_instance_._instance.get_mutable()->binaryvalues_ = const_cast< ::types::BinaryConstants*>(
                ::types::BinaryConstants::internal_default_instance());
    }
    class InNode::_Internal {
    public:
        using HasBits = decltype(std::declval<InNode>()._has_bits_);
        static const ::types::FieldNode& field(const InNode* msg);
        static void set_has_field(HasBits* has_bits) {
            (*has_bits)[0] |= 1u;
        }
        static const ::types::IntConstants& intvalues(const InNode* msg);
        static void set_has_intvalues(HasBits* has_bits) {
            (*has_bits)[0] |= 2u;
        }
        static const ::types::LongConstants& longvalues(const InNode* msg);
        static void set_has_longvalues(HasBits* has_bits) {
            (*has_bits)[0] |= 4u;
        }
        static const ::types::StringConstants& stringvalues(const InNode* msg);
        static void set_has_stringvalues(HasBits* has_bits) {
            (*has_bits)[0] |= 8u;
        }
        static const ::types::BinaryConstants& binaryvalues(const InNode* msg);
        static void set_has_binaryvalues(HasBits* has_bits) {
            (*has_bits)[0] |= 16u;
        }
    };

    const ::types::FieldNode&
    InNode::_Internal::field(const InNode* msg) {
        return *msg->field_;
    }
    const ::types::IntConstants&
    InNode::_Internal::intvalues(const InNode* msg) {
        return *msg->intvalues_;
    }
    const ::types::LongConstants&
    InNode::_Internal::longvalues(const InNode* msg) {
        return *msg->longvalues_;
    }
    const ::types::StringConstants&
    InNode::_Internal::stringvalues(const InNode* msg) {
        return *msg->stringvalues_;
    }
    const ::types::BinaryConstants&
    InNode::_Internal::binaryvalues(const InNode* msg) {
        return *msg->binaryvalues_;
    }
    InNode::InNode()
            : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
        SharedCtor();
        // @@protoc_insertion_point(constructor:types.InNode)
    }
    InNode::InNode(const InNode& from)
            : ::PROTOBUF_NAMESPACE_ID::Message(),
              _internal_metadata_(nullptr),
              _has_bits_(from._has_bits_) {
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        if (from._internal_has_field()) {
            field_ = new ::types::FieldNode(*from.field_);
        } else {
            field_ = nullptr;
        }
        if (from._internal_has_intvalues()) {
            intvalues_ = new ::types::IntConstants(*from.intvalues_);
        } else {
            intvalues_ = nullptr;
        }
        if (from._internal_has_longvalues()) {
            longvalues_ = new ::types::LongConstants(*from.longvalues_);
        } else {
            longvalues_ = nullptr;
        }
        if (from._internal_has_stringvalues()) {
            stringvalues_ = new ::types::StringConstants(*from.stringvalues_);
        } else {
            stringvalues_ = nullptr;
        }
        if (from._internal_has_binaryvalues()) {
            binaryvalues_ = new ::types::BinaryConstants(*from.binaryvalues_);
        } else {
            binaryvalues_ = nullptr;
        }
        // @@protoc_insertion_point(copy_constructor:types.InNode)
    }

    void InNode::SharedCtor() {
        ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_InNode_Types_2eproto.base);
        ::memset(&field_, 0, static_cast<size_t>(
                                     reinterpret_cast<char*>(&binaryvalues_) -
                                     reinterpret_cast<char*>(&field_)) + sizeof(binaryvalues_));
    }

    InNode::~InNode() {
        // @@protoc_insertion_point(destructor:types.InNode)
        SharedDtor();
    }

    void InNode::SharedDtor() {
        if (this != internal_default_instance()) delete field_;
        if (this != internal_default_instance()) delete intvalues_;
        if (this != internal_default_instance()) delete longvalues_;
        if (this != internal_default_instance()) delete stringvalues_;
        if (this != internal_default_instance()) delete binaryvalues_;
    }

    void InNode::SetCachedSize(int size) const {
        _cached_size_.Set(size);
    }
    const InNode& InNode::default_instance() {
        ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_InNode_Types_2eproto.base);
        return *internal_default_instance();
    }


    void InNode::Clear() {
// @@protoc_insertion_point(message_clear_start:types.InNode)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        cached_has_bits = _has_bits_[0];
        if (cached_has_bits & 0x0000001fu) {
            if (cached_has_bits & 0x00000001u) {
                        GOOGLE_DCHECK(field_ != nullptr);
                field_->Clear();
            }
            if (cached_has_bits & 0x00000002u) {
                        GOOGLE_DCHECK(intvalues_ != nullptr);
                intvalues_->Clear();
            }
            if (cached_has_bits & 0x00000004u) {
                        GOOGLE_DCHECK(longvalues_ != nullptr);
                longvalues_->Clear();
            }
            if (cached_has_bits & 0x00000008u) {
                        GOOGLE_DCHECK(stringvalues_ != nullptr);
                stringvalues_->Clear();
            }
            if (cached_has_bits & 0x00000010u) {
                        GOOGLE_DCHECK(binaryvalues_ != nullptr);
                binaryvalues_->Clear();
            }
        }
        _has_bits_.Clear();
        _internal_metadata_.Clear();
    }

    const char* InNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
        _Internal::HasBits has_bits{};
        while (!ctx->Done(&ptr)) {
            ::PROTOBUF_NAMESPACE_ID::uint32 tag;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
            CHK_(ptr);
            switch (tag >> 3) {
                // optional .types.FieldNode field = 1;
                case 1:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
                        ptr = ctx->ParseMessage(_internal_mutable_field(), ptr);
                        CHK_(ptr);
                    } else goto handle_unusual;
                    continue;
                    // optional .types.IntConstants intValues = 2;
                case 2:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
                        ptr = ctx->ParseMessage(_internal_mutable_intvalues(), ptr);
                        CHK_(ptr);
                    } else goto handle_unusual;
                    continue;
                    // optional .types.LongConstants longValues = 3;
                case 3:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
                        ptr = ctx->ParseMessage(_internal_mutable_longvalues(), ptr);
                        CHK_(ptr);
                    } else goto handle_unusual;
                    continue;
                    // optional .types.StringConstants stringValues = 4;
                case 4:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
                        ptr = ctx->ParseMessage(_internal_mutable_stringvalues(), ptr);
                        CHK_(ptr);
                    } else goto handle_unusual;
                    continue;
                    // optional .types.BinaryConstants binaryValues = 5;
                case 5:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
                        ptr = ctx->ParseMessage(_internal_mutable_binaryvalues(), ptr);
                        CHK_(ptr);
                    } else goto handle_unusual;
                    continue;
                default: {
                    handle_unusual:
                    if ((tag & 7) == 4 || tag == 0) {
                        ctx->SetLastTag(tag);
                        goto success;
                    }
                    ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
                    CHK_(ptr != nullptr);
                    continue;
                }
            }  // switch
        }  // while
        success:
        _has_bits_.Or(has_bits);
        return ptr;
        failure:
        ptr = nullptr;
        goto success;
#undef CHK_
    }

    ::PROTOBUF_NAMESPACE_ID::uint8* InNode::_InternalSerialize(
            ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
        // @@protoc_insertion_point(serialize_to_array_start:types.InNode)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        cached_has_bits = _has_bits_[0];
        // optional .types.FieldNode field = 1;
        if (cached_has_bits & 0x00000001u) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
            InternalWriteMessage(
                    1, _Internal::field(this), target, stream);
        }

        // optional .types.IntConstants intValues = 2;
        if (cached_has_bits & 0x00000002u) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
            InternalWriteMessage(
                    2, _Internal::intvalues(this), target, stream);
        }

        // optional .types.LongConstants longValues = 3;
        if (cached_has_bits & 0x00000004u) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
            InternalWriteMessage(
                    3, _Internal::longvalues(this), target, stream);
        }

        // optional .types.StringConstants stringValues = 4;
        if (cached_has_bits & 0x00000008u) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
            InternalWriteMessage(
                    4, _Internal::stringvalues(this), target, stream);
        }

        // optional .types.BinaryConstants binaryValues = 5;
        if (cached_has_bits & 0x00000010u) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
            InternalWriteMessage(
                    5, _Internal::binaryvalues(this), target, stream);
        }

        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
                    _internal_metadata_.unknown_fields(), target, stream);
        }
        // @@protoc_insertion_point(serialize_to_array_end:types.InNode)
        return target;
    }

    size_t InNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:types.InNode)
        size_t total_size = 0;

        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        cached_has_bits = _has_bits_[0];
        if (cached_has_bits & 0x0000001fu) {
            // optional .types.FieldNode field = 1;
            if (cached_has_bits & 0x00000001u) {
                total_size += 1 +
                              ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                                      *field_);
            }

            // optional .types.IntConstants intValues = 2;
            if (cached_has_bits & 0x00000002u) {
                total_size += 1 +
                              ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                                      *intvalues_);
            }

            // optional .types.LongConstants longValues = 3;
            if (cached_has_bits & 0x00000004u) {
                total_size += 1 +
                              ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                                      *longvalues_);
            }

            // optional .types.StringConstants stringValues = 4;
            if (cached_has_bits & 0x00000008u) {
                total_size += 1 +
                              ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                                      *stringvalues_);
            }

            // optional .types.BinaryConstants binaryValues = 5;
            if (cached_has_bits & 0x00000010u) {
                total_size += 1 +
                              ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                                      *binaryvalues_);
            }

        }
        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
                    _internal_metadata_, total_size, &_cached_size_);
        }
        int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
        SetCachedSize(cached_size);
        return total_size;
    }

    void InNode::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:types.InNode)
                GOOGLE_DCHECK_NE(&from, this);
        const InNode* source =
                ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<InNode>(
                        &from);
        if (source == nullptr) {
            // @@protoc_insertion_point(generalized_merge_from_cast_fail:types.InNode)
            ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
        } else {
            // @@protoc_insertion_point(generalized_merge_from_cast_success:types.InNode)
            MergeFrom(*source);
        }
    }

    void InNode::MergeFrom(const InNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:types.InNode)
                GOOGLE_DCHECK_NE(&from, this);
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        cached_has_bits = from._has_bits_[0];
        if (cached_has_bits & 0x0000001fu) {
            if (cached_has_bits & 0x00000001u) {
                _internal_mutable_field()->::types::FieldNode::MergeFrom(from._internal_field());
            }
            if (cached_has_bits & 0x00000002u) {
                _internal_mutable_intvalues()->::types::IntConstants::MergeFrom(from._internal_intvalues());
            }
            if (cached_has_bits & 0x00000004u) {
                _internal_mutable_longvalues()->::types::LongConstants::MergeFrom(from._internal_longvalues());
            }
            if (cached_has_bits & 0x00000008u) {
                _internal_mutable_stringvalues()->::types::StringConstants::MergeFrom(from._internal_stringvalues());
            }
            if (cached_has_bits & 0x00000010u) {
                _internal_mutable_binaryvalues()->::types::BinaryConstants::MergeFrom(from._internal_binaryvalues());
            }
        }
    }

    void InNode::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:types.InNode)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    void InNode::CopyFrom(const InNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:types.InNode)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    bool InNode::IsInitialized() const {
        return true;
    }

    void InNode::InternalSwap(InNode* other) {
        using std::swap;
        _internal_metadata_.Swap(&other->_internal_metadata_);
        swap(_has_bits_[0], other->_has_bits_[0]);
        swap(field_, other->field_);
        swap(intvalues_, other->intvalues_);
        swap(longvalues_, other->longvalues_);
        swap(stringvalues_, other->stringvalues_);
        swap(binaryvalues_, other->binaryvalues_);
    }

    ::PROTOBUF_NAMESPACE_ID::Metadata InNode::GetMetadata() const {
        return GetMetadataStatic();
    }


// ===================================================================

    void IntConstants::InitAsDefaultInstance() {
    }
    class IntConstants::_Internal {
    public:
        using HasBits = decltype(std::declval<IntConstants>()._has_bits_);
    };

    IntConstants::IntConstants()
            : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
        SharedCtor();
        // @@protoc_insertion_point(constructor:types.IntConstants)
    }
    IntConstants::IntConstants(const IntConstants& from)
            : ::PROTOBUF_NAMESPACE_ID::Message(),
              _internal_metadata_(nullptr),
              _has_bits_(from._has_bits_),
              intvalues_(from.intvalues_) {
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        // @@protoc_insertion_point(copy_constructor:types.IntConstants)
    }

    void IntConstants::SharedCtor() {
        ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_IntConstants_Types_2eproto.base);
    }

    IntConstants::~IntConstants() {
        // @@protoc_insertion_point(destructor:types.IntConstants)
        SharedDtor();
    }

    void IntConstants::SharedDtor() {
    }

    void IntConstants::SetCachedSize(int size) const {
        _cached_size_.Set(size);
    }
    const IntConstants& IntConstants::default_instance() {
        ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_IntConstants_Types_2eproto.base);
        return *internal_default_instance();
    }


    void IntConstants::Clear() {
// @@protoc_insertion_point(message_clear_start:types.IntConstants)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        intvalues_.Clear();
        _has_bits_.Clear();
        _internal_metadata_.Clear();
    }

    const char* IntConstants::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
        while (!ctx->Done(&ptr)) {
            ::PROTOBUF_NAMESPACE_ID::uint32 tag;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
            CHK_(ptr);
            switch (tag >> 3) {
                // repeated .types.IntNode intValues = 1;
                case 1:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
                        ptr -= 1;
                        do {
                            ptr += 1;
                            ptr = ctx->ParseMessage(_internal_add_intvalues(), ptr);
                            CHK_(ptr);
                            if (!ctx->DataAvailable(ptr)) break;
                        } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
                    } else goto handle_unusual;
                    continue;
                default: {
                    handle_unusual:
                    if ((tag & 7) == 4 || tag == 0) {
                        ctx->SetLastTag(tag);
                        goto success;
                    }
                    ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
                    CHK_(ptr != nullptr);
                    continue;
                }
            }  // switch
        }  // while
        success:
        return ptr;
        failure:
        ptr = nullptr;
        goto success;
#undef CHK_
    }

    ::PROTOBUF_NAMESPACE_ID::uint8* IntConstants::_InternalSerialize(
            ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
        // @@protoc_insertion_point(serialize_to_array_start:types.IntConstants)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        // repeated .types.IntNode intValues = 1;
        for (unsigned int i = 0,
                     n = static_cast<unsigned int>(this->_internal_intvalues_size()); i < n; i++) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
            InternalWriteMessage(1, this->_internal_intvalues(i), target, stream);
        }

        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
                    _internal_metadata_.unknown_fields(), target, stream);
        }
        // @@protoc_insertion_point(serialize_to_array_end:types.IntConstants)
        return target;
    }

    size_t IntConstants::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:types.IntConstants)
        size_t total_size = 0;

        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        // repeated .types.IntNode intValues = 1;
        total_size += 1UL * this->_internal_intvalues_size();
        for (const auto& msg : this->intvalues_) {
            total_size +=
                    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
        }

        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
                    _internal_metadata_, total_size, &_cached_size_);
        }
        int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
        SetCachedSize(cached_size);
        return total_size;
    }

    void IntConstants::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:types.IntConstants)
                GOOGLE_DCHECK_NE(&from, this);
        const IntConstants* source =
                ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<IntConstants>(
                        &from);
        if (source == nullptr) {
            // @@protoc_insertion_point(generalized_merge_from_cast_fail:types.IntConstants)
            ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
        } else {
            // @@protoc_insertion_point(generalized_merge_from_cast_success:types.IntConstants)
            MergeFrom(*source);
        }
    }

    void IntConstants::MergeFrom(const IntConstants& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:types.IntConstants)
                GOOGLE_DCHECK_NE(&from, this);
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        intvalues_.MergeFrom(from.intvalues_);
    }

    void IntConstants::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:types.IntConstants)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    void IntConstants::CopyFrom(const IntConstants& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:types.IntConstants)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    bool IntConstants::IsInitialized() const {
        return true;
    }

    void IntConstants::InternalSwap(IntConstants* other) {
        using std::swap;
        _internal_metadata_.Swap(&other->_internal_metadata_);
        swap(_has_bits_[0], other->_has_bits_[0]);
        intvalues_.InternalSwap(&other->intvalues_);
    }

    ::PROTOBUF_NAMESPACE_ID::Metadata IntConstants::GetMetadata() const {
        return GetMetadataStatic();
    }


// ===================================================================

    void LongConstants::InitAsDefaultInstance() {
    }
    class LongConstants::_Internal {
    public:
        using HasBits = decltype(std::declval<LongConstants>()._has_bits_);
    };

    LongConstants::LongConstants()
            : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
        SharedCtor();
        // @@protoc_insertion_point(constructor:types.LongConstants)
    }
    LongConstants::LongConstants(const LongConstants& from)
            : ::PROTOBUF_NAMESPACE_ID::Message(),
              _internal_metadata_(nullptr),
              _has_bits_(from._has_bits_),
              longvalues_(from.longvalues_) {
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        // @@protoc_insertion_point(copy_constructor:types.LongConstants)
    }

    void LongConstants::SharedCtor() {
        ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_LongConstants_Types_2eproto.base);
    }

    LongConstants::~LongConstants() {
        // @@protoc_insertion_point(destructor:types.LongConstants)
        SharedDtor();
    }

    void LongConstants::SharedDtor() {
    }

    void LongConstants::SetCachedSize(int size) const {
        _cached_size_.Set(size);
    }
    const LongConstants& LongConstants::default_instance() {
        ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_LongConstants_Types_2eproto.base);
        return *internal_default_instance();
    }


    void LongConstants::Clear() {
// @@protoc_insertion_point(message_clear_start:types.LongConstants)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        longvalues_.Clear();
        _has_bits_.Clear();
        _internal_metadata_.Clear();
    }

    const char* LongConstants::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
        while (!ctx->Done(&ptr)) {
            ::PROTOBUF_NAMESPACE_ID::uint32 tag;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
            CHK_(ptr);
            switch (tag >> 3) {
                // repeated .types.LongNode longValues = 1;
                case 1:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
                        ptr -= 1;
                        do {
                            ptr += 1;
                            ptr = ctx->ParseMessage(_internal_add_longvalues(), ptr);
                            CHK_(ptr);
                            if (!ctx->DataAvailable(ptr)) break;
                        } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
                    } else goto handle_unusual;
                    continue;
                default: {
                    handle_unusual:
                    if ((tag & 7) == 4 || tag == 0) {
                        ctx->SetLastTag(tag);
                        goto success;
                    }
                    ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
                    CHK_(ptr != nullptr);
                    continue;
                }
            }  // switch
        }  // while
        success:
        return ptr;
        failure:
        ptr = nullptr;
        goto success;
#undef CHK_
    }

    ::PROTOBUF_NAMESPACE_ID::uint8* LongConstants::_InternalSerialize(
            ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
        // @@protoc_insertion_point(serialize_to_array_start:types.LongConstants)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        // repeated .types.LongNode longValues = 1;
        for (unsigned int i = 0,
                     n = static_cast<unsigned int>(this->_internal_longvalues_size()); i < n; i++) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
            InternalWriteMessage(1, this->_internal_longvalues(i), target, stream);
        }

        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
                    _internal_metadata_.unknown_fields(), target, stream);
        }
        // @@protoc_insertion_point(serialize_to_array_end:types.LongConstants)
        return target;
    }

    size_t LongConstants::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:types.LongConstants)
        size_t total_size = 0;

        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        // repeated .types.LongNode longValues = 1;
        total_size += 1UL * this->_internal_longvalues_size();
        for (const auto& msg : this->longvalues_) {
            total_size +=
                    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
        }

        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
                    _internal_metadata_, total_size, &_cached_size_);
        }
        int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
        SetCachedSize(cached_size);
        return total_size;
    }

    void LongConstants::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:types.LongConstants)
                GOOGLE_DCHECK_NE(&from, this);
        const LongConstants* source =
                ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<LongConstants>(
                        &from);
        if (source == nullptr) {
            // @@protoc_insertion_point(generalized_merge_from_cast_fail:types.LongConstants)
            ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
        } else {
            // @@protoc_insertion_point(generalized_merge_from_cast_success:types.LongConstants)
            MergeFrom(*source);
        }
    }

    void LongConstants::MergeFrom(const LongConstants& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:types.LongConstants)
                GOOGLE_DCHECK_NE(&from, this);
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        longvalues_.MergeFrom(from.longvalues_);
    }

    void LongConstants::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:types.LongConstants)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    void LongConstants::CopyFrom(const LongConstants& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:types.LongConstants)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    bool LongConstants::IsInitialized() const {
        return true;
    }

    void LongConstants::InternalSwap(LongConstants* other) {
        using std::swap;
        _internal_metadata_.Swap(&other->_internal_metadata_);
        swap(_has_bits_[0], other->_has_bits_[0]);
        longvalues_.InternalSwap(&other->longvalues_);
    }

    ::PROTOBUF_NAMESPACE_ID::Metadata LongConstants::GetMetadata() const {
        return GetMetadataStatic();
    }


// ===================================================================

    void StringConstants::InitAsDefaultInstance() {
    }
    class StringConstants::_Internal {
    public:
        using HasBits = decltype(std::declval<StringConstants>()._has_bits_);
    };

    StringConstants::StringConstants()
            : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
        SharedCtor();
        // @@protoc_insertion_point(constructor:types.StringConstants)
    }
    StringConstants::StringConstants(const StringConstants& from)
            : ::PROTOBUF_NAMESPACE_ID::Message(),
              _internal_metadata_(nullptr),
              _has_bits_(from._has_bits_),
              stringvalues_(from.stringvalues_) {
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        // @@protoc_insertion_point(copy_constructor:types.StringConstants)
    }

    void StringConstants::SharedCtor() {
        ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_StringConstants_Types_2eproto.base);
    }

    StringConstants::~StringConstants() {
        // @@protoc_insertion_point(destructor:types.StringConstants)
        SharedDtor();
    }

    void StringConstants::SharedDtor() {
    }

    void StringConstants::SetCachedSize(int size) const {
        _cached_size_.Set(size);
    }
    const StringConstants& StringConstants::default_instance() {
        ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_StringConstants_Types_2eproto.base);
        return *internal_default_instance();
    }


    void StringConstants::Clear() {
// @@protoc_insertion_point(message_clear_start:types.StringConstants)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        stringvalues_.Clear();
        _has_bits_.Clear();
        _internal_metadata_.Clear();
    }

    const char* StringConstants::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
        while (!ctx->Done(&ptr)) {
            ::PROTOBUF_NAMESPACE_ID::uint32 tag;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
            CHK_(ptr);
            switch (tag >> 3) {
                // repeated .types.StringNode stringValues = 1;
                case 1:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
                        ptr -= 1;
                        do {
                            ptr += 1;
                            ptr = ctx->ParseMessage(_internal_add_stringvalues(), ptr);
                            CHK_(ptr);
                            if (!ctx->DataAvailable(ptr)) break;
                        } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
                    } else goto handle_unusual;
                    continue;
                default: {
                    handle_unusual:
                    if ((tag & 7) == 4 || tag == 0) {
                        ctx->SetLastTag(tag);
                        goto success;
                    }
                    ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
                    CHK_(ptr != nullptr);
                    continue;
                }
            }  // switch
        }  // while
        success:
        return ptr;
        failure:
        ptr = nullptr;
        goto success;
#undef CHK_
    }

    ::PROTOBUF_NAMESPACE_ID::uint8* StringConstants::_InternalSerialize(
            ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
        // @@protoc_insertion_point(serialize_to_array_start:types.StringConstants)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        // repeated .types.StringNode stringValues = 1;
        for (unsigned int i = 0,
                     n = static_cast<unsigned int>(this->_internal_stringvalues_size()); i < n; i++) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
            InternalWriteMessage(1, this->_internal_stringvalues(i), target, stream);
        }

        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
                    _internal_metadata_.unknown_fields(), target, stream);
        }
        // @@protoc_insertion_point(serialize_to_array_end:types.StringConstants)
        return target;
    }

    size_t StringConstants::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:types.StringConstants)
        size_t total_size = 0;

        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        // repeated .types.StringNode stringValues = 1;
        total_size += 1UL * this->_internal_stringvalues_size();
        for (const auto& msg : this->stringvalues_) {
            total_size +=
                    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
        }

        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
                    _internal_metadata_, total_size, &_cached_size_);
        }
        int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
        SetCachedSize(cached_size);
        return total_size;
    }

    void StringConstants::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:types.StringConstants)
                GOOGLE_DCHECK_NE(&from, this);
        const StringConstants* source =
                ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<StringConstants>(
                        &from);
        if (source == nullptr) {
            // @@protoc_insertion_point(generalized_merge_from_cast_fail:types.StringConstants)
            ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
        } else {
            // @@protoc_insertion_point(generalized_merge_from_cast_success:types.StringConstants)
            MergeFrom(*source);
        }
    }

    void StringConstants::MergeFrom(const StringConstants& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:types.StringConstants)
                GOOGLE_DCHECK_NE(&from, this);
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        stringvalues_.MergeFrom(from.stringvalues_);
    }

    void StringConstants::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:types.StringConstants)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    void StringConstants::CopyFrom(const StringConstants& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:types.StringConstants)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    bool StringConstants::IsInitialized() const {
        return true;
    }

    void StringConstants::InternalSwap(StringConstants* other) {
        using std::swap;
        _internal_metadata_.Swap(&other->_internal_metadata_);
        swap(_has_bits_[0], other->_has_bits_[0]);
        stringvalues_.InternalSwap(&other->stringvalues_);
    }

    ::PROTOBUF_NAMESPACE_ID::Metadata StringConstants::GetMetadata() const {
        return GetMetadataStatic();
    }


// ===================================================================

    void BinaryConstants::InitAsDefaultInstance() {
    }
    class BinaryConstants::_Internal {
    public:
        using HasBits = decltype(std::declval<BinaryConstants>()._has_bits_);
    };

    BinaryConstants::BinaryConstants()
            : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
        SharedCtor();
        // @@protoc_insertion_point(constructor:types.BinaryConstants)
    }
    BinaryConstants::BinaryConstants(const BinaryConstants& from)
            : ::PROTOBUF_NAMESPACE_ID::Message(),
              _internal_metadata_(nullptr),
              _has_bits_(from._has_bits_),
              binaryvalues_(from.binaryvalues_) {
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        // @@protoc_insertion_point(copy_constructor:types.BinaryConstants)
    }

    void BinaryConstants::SharedCtor() {
        ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_BinaryConstants_Types_2eproto.base);
    }

    BinaryConstants::~BinaryConstants() {
        // @@protoc_insertion_point(destructor:types.BinaryConstants)
        SharedDtor();
    }

    void BinaryConstants::SharedDtor() {
    }

    void BinaryConstants::SetCachedSize(int size) const {
        _cached_size_.Set(size);
    }
    const BinaryConstants& BinaryConstants::default_instance() {
        ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_BinaryConstants_Types_2eproto.base);
        return *internal_default_instance();
    }


    void BinaryConstants::Clear() {
// @@protoc_insertion_point(message_clear_start:types.BinaryConstants)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        binaryvalues_.Clear();
        _has_bits_.Clear();
        _internal_metadata_.Clear();
    }

    const char* BinaryConstants::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
        while (!ctx->Done(&ptr)) {
            ::PROTOBUF_NAMESPACE_ID::uint32 tag;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
            CHK_(ptr);
            switch (tag >> 3) {
                // repeated .types.BinaryNode binaryValues = 1;
                case 1:
                    if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
                        ptr -= 1;
                        do {
                            ptr += 1;
                            ptr = ctx->ParseMessage(_internal_add_binaryvalues(), ptr);
                            CHK_(ptr);
                            if (!ctx->DataAvailable(ptr)) break;
                        } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
                    } else goto handle_unusual;
                    continue;
                default: {
                    handle_unusual:
                    if ((tag & 7) == 4 || tag == 0) {
                        ctx->SetLastTag(tag);
                        goto success;
                    }
                    ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
                    CHK_(ptr != nullptr);
                    continue;
                }
            }  // switch
        }  // while
        success:
        return ptr;
        failure:
        ptr = nullptr;
        goto success;
#undef CHK_
    }

    ::PROTOBUF_NAMESPACE_ID::uint8* BinaryConstants::_InternalSerialize(
            ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
        // @@protoc_insertion_point(serialize_to_array_start:types.BinaryConstants)
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        // repeated .types.BinaryNode binaryValues = 1;
        for (unsigned int i = 0,
                     n = static_cast<unsigned int>(this->_internal_binaryvalues_size()); i < n; i++) {
            target = stream->EnsureSpace(target);
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
            InternalWriteMessage(1, this->_internal_binaryvalues(i), target, stream);
        }

        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
                    _internal_metadata_.unknown_fields(), target, stream);
        }
        // @@protoc_insertion_point(serialize_to_array_end:types.BinaryConstants)
        return target;
    }

    size_t BinaryConstants::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:types.BinaryConstants)
        size_t total_size = 0;

        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        // Prevent compiler warnings about cached_has_bits being unused
        (void) cached_has_bits;

        // repeated .types.BinaryNode binaryValues = 1;
        total_size += 1UL * this->_internal_binaryvalues_size();
        for (const auto& msg : this->binaryvalues_) {
            total_size +=
                    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
        }

        if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
            return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
                    _internal_metadata_, total_size, &_cached_size_);
        }
        int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
        SetCachedSize(cached_size);
        return total_size;
    }

    void BinaryConstants::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:types.BinaryConstants)
                GOOGLE_DCHECK_NE(&from, this);
        const BinaryConstants* source =
                ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<BinaryConstants>(
                        &from);
        if (source == nullptr) {
            // @@protoc_insertion_point(generalized_merge_from_cast_fail:types.BinaryConstants)
            ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
        } else {
            // @@protoc_insertion_point(generalized_merge_from_cast_success:types.BinaryConstants)
            MergeFrom(*source);
        }
    }

    void BinaryConstants::MergeFrom(const BinaryConstants& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:types.BinaryConstants)
                GOOGLE_DCHECK_NE(&from, this);
        _internal_metadata_.MergeFrom(from._internal_metadata_);
        ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
        (void) cached_has_bits;

        binaryvalues_.MergeFrom(from.binaryvalues_);
    }

    void BinaryConstants::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:types.BinaryConstants)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    void BinaryConstants::CopyFrom(const BinaryConstants& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:types.BinaryConstants)
        if (&from == this) return;
        Clear();
        MergeFrom(from);
    }

    bool BinaryConstants::IsInitialized() const {
        return true;
    }

    void BinaryConstants::InternalSwap(BinaryConstants* other) {
        using std::swap;
        _internal_metadata_.Swap(&other->_internal_metadata_);
        swap(_has_bits_[0], other->_has_bits_[0]);
        binaryvalues_.InternalSwap(&other->binaryvalues_);
    }

    ::PROTOBUF_NAMESPACE_ID::Metadata BinaryConstants::GetMetadata() const {
        return GetMetadataStatic();
    }


// @@protoc_insertion_point(namespace_scope)
}  // namespace types
PROTOBUF_NAMESPACE_OPEN
        template<> PROTOBUF_NOINLINE ::types::ExtGandivaType* Arena::CreateMaybeMessage< ::types::ExtGandivaType >(Arena* arena) {
            return Arena::CreateInternal< ::types::ExtGandivaType >(arena);
        }
        template<> PROTOBUF_NOINLINE ::types::Field* Arena::CreateMaybeMessage< ::types::Field >(Arena* arena) {
            return Arena::CreateInternal< ::types::Field >(arena);
        }
        template<> PROTOBUF_NOINLINE ::types::FieldNode* Arena::CreateMaybeMessage< ::types::FieldNode >(Arena* arena) {
            return Arena::CreateInternal< ::types::FieldNode >(arena);
        }
        template<> PROTOBUF_NOINLINE ::types::FunctionNode* Arena::CreateMaybeMessage< ::types::FunctionNode >(Arena* arena) {
            return Arena::CreateInternal< ::types::FunctionNode >(arena);
        }
        template<> PROTOBUF_NOINLINE ::types::IfNode* Arena::CreateMaybeMessage< ::types::IfNode >(Arena* arena) {
            return Arena::CreateInternal< ::types::IfNode >(arena);
        }
        template<> PROTOBUF_NOINLINE ::types::AndNode* Arena::CreateMaybeMessage< ::types::AndNode >(Arena* arena) {
            return Arena::CreateInternal< ::types::AndNode >(arena);
        }
        template<> PROTOBUF_NOINLINE ::types::OrNode* Arena::CreateMaybeMessage< ::types::OrNode >(Arena* arena) {
            return Arena::CreateInternal< ::types::OrNode >(arena);
        }
        template<> PROTOBUF_NOINLINE ::types::NullNode* Arena::CreateMaybeMessage< ::types::NullNode >(Arena* arena) {
            return Arena::CreateInternal< ::types::NullNode >(arena);
        }
        template<> PROTOBUF_NOINLINE ::types::IntNode* Arena::CreateMaybeMessage< ::types::IntNode >(Arena* arena) {
            return Arena::CreateInternal< ::types::IntNode >(arena);
        }
        template<> PROTOBUF_NOINLINE ::types::FloatNode* Arena::CreateMaybeMessage< ::types::FloatNode >(Arena* arena) {
            return Arena::CreateInternal< ::types::FloatNode >(arena);
        }
        template<> PROTOBUF_NOINLINE ::types::DoubleNode* Arena::CreateMaybeMessage< ::types::DoubleNode >(Arena* arena) {
            return Arena::CreateInternal< ::types::DoubleNode >(arena);
        }
        template<> PROTOBUF_NOINLINE ::types::BooleanNode* Arena::CreateMaybeMessage< ::types::BooleanNode >(Arena* arena) {
            return Arena::CreateInternal< ::types::BooleanNode >(arena);
        }
        template<> PROTOBUF_NOINLINE ::types::LongNode* Arena::CreateMaybeMessage< ::types::LongNode >(Arena* arena) {
            return Arena::CreateInternal< ::types::LongNode >(arena);
        }
        template<> PROTOBUF_NOINLINE ::types::StringNode* Arena::CreateMaybeMessage< ::types::StringNode >(Arena* arena) {
            return Arena::CreateInternal< ::types::StringNode >(arena);
        }
        template<> PROTOBUF_NOINLINE ::types::BinaryNode* Arena::CreateMaybeMessage< ::types::BinaryNode >(Arena* arena) {
            return Arena::CreateInternal< ::types::BinaryNode >(arena);
        }
        template<> PROTOBUF_NOINLINE ::types::DecimalNode* Arena::CreateMaybeMessage< ::types::DecimalNode >(Arena* arena) {
            return Arena::CreateInternal< ::types::DecimalNode >(arena);
        }
        template<> PROTOBUF_NOINLINE ::types::TreeNode* Arena::CreateMaybeMessage< ::types::TreeNode >(Arena* arena) {
            return Arena::CreateInternal< ::types::TreeNode >(arena);
        }
        template<> PROTOBUF_NOINLINE ::types::ExpressionRoot* Arena::CreateMaybeMessage< ::types::ExpressionRoot >(Arena* arena) {
            return Arena::CreateInternal< ::types::ExpressionRoot >(arena);
        }
        template<> PROTOBUF_NOINLINE ::types::ExpressionList* Arena::CreateMaybeMessage< ::types::ExpressionList >(Arena* arena) {
            return Arena::CreateInternal< ::types::ExpressionList >(arena);
        }
        template<> PROTOBUF_NOINLINE ::types::Condition* Arena::CreateMaybeMessage< ::types::Condition >(Arena* arena) {
            return Arena::CreateInternal< ::types::Condition >(arena);
        }
        template<> PROTOBUF_NOINLINE ::types::Schema* Arena::CreateMaybeMessage< ::types::Schema >(Arena* arena) {
            return Arena::CreateInternal< ::types::Schema >(arena);
        }
        template<> PROTOBUF_NOINLINE ::types::GandivaDataTypes* Arena::CreateMaybeMessage< ::types::GandivaDataTypes >(Arena* arena) {
            return Arena::CreateInternal< ::types::GandivaDataTypes >(arena);
        }
        template<> PROTOBUF_NOINLINE ::types::GandivaFunctions* Arena::CreateMaybeMessage< ::types::GandivaFunctions >(Arena* arena) {
            return Arena::CreateInternal< ::types::GandivaFunctions >(arena);
        }
        template<> PROTOBUF_NOINLINE ::types::FunctionSignature* Arena::CreateMaybeMessage< ::types::FunctionSignature >(Arena* arena) {
            return Arena::CreateInternal< ::types::FunctionSignature >(arena);
        }
        template<> PROTOBUF_NOINLINE ::types::InNode* Arena::CreateMaybeMessage< ::types::InNode >(Arena* arena) {
            return Arena::CreateInternal< ::types::InNode >(arena);
        }
        template<> PROTOBUF_NOINLINE ::types::IntConstants* Arena::CreateMaybeMessage< ::types::IntConstants >(Arena* arena) {
            return Arena::CreateInternal< ::types::IntConstants >(arena);
        }
        template<> PROTOBUF_NOINLINE ::types::LongConstants* Arena::CreateMaybeMessage< ::types::LongConstants >(Arena* arena) {
            return Arena::CreateInternal< ::types::LongConstants >(arena);
        }
        template<> PROTOBUF_NOINLINE ::types::StringConstants* Arena::CreateMaybeMessage< ::types::StringConstants >(Arena* arena) {
            return Arena::CreateInternal< ::types::StringConstants >(arena);
        }
        template<> PROTOBUF_NOINLINE ::types::BinaryConstants* Arena::CreateMaybeMessage< ::types::BinaryConstants >(Arena* arena) {
            return Arena::CreateInternal< ::types::BinaryConstants >(arena);
        }
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
